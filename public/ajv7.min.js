!(function (e, t) {
  "object" == typeof exports && "undefined" != typeof module
    ? t(exports)
    : "function" == typeof define && define.amd
    ? define(["exports"], t)
    : t(
        ((e =
          "undefined" != typeof globalThis ? globalThis : e || self).ajv2019 =
          {})
      );
})(this, function (e) {
  "use strict";
  class r {}
  const t = /^[a-z$_][a-z$_0-9]*$/i;
  class p extends r {
    constructor(e) {
      if ((super(), !t.test(e)))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = e;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return !1;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  class m extends r {
    constructor(e) {
      super(), (this._items = "string" == typeof e ? [e] : e);
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (1 < this._items.length) return !1;
      var e = this._items[0];
      return "" === e || '""' === e;
    }
    get str() {
      var e;
      return null !== (e = this._str) && void 0 !== e
        ? e
        : (this._str = this._items.reduce((e, t) => `${e}${t}`, ""));
    }
    get names() {
      var e;
      return null !== (e = this._names) && void 0 !== e
        ? e
        : (this._names = this._items.reduce(
            (e, t) => (t instanceof p && (e[t.str] = (e[t.str] || 0) + 1), e),
            {}
          ));
    }
  }
  const y = new m("");
  function v(e, ...t) {
    const r = [e[0]];
    let s = 0;
    for (; s < t.length; ) o(r, t[s]), r.push(e[++s]);
    return new m(r);
  }
  const a = new m("+");
  function f(e, ...t) {
    const r = [n(e[0])];
    let s = 0;
    for (; s < t.length; ) r.push(a), o(r, t[s]), r.push(a, n(e[++s]));
    return (
      (function (e) {
        let t = 1;
        for (; t < e.length - 1; ) {
          if (e[t] === a) {
            var r = (function (e, t) {
              return '""' === t
                ? e
                : '""' === e
                ? t
                : "string" != typeof e
                ? "string" != typeof t || '"' !== t[0] || e instanceof p
                  ? void 0
                  : `"${e}${t.slice(1)}`
                : t instanceof p || '"' !== e[e.length - 1]
                ? void 0
                : "string" != typeof t
                ? `${e.slice(0, -1)}${t}"`
                : '"' === t[0]
                ? e.slice(0, -1) + t.slice(1)
                : void 0;
            })(e[t - 1], e[t + 1]);
            if (void 0 !== r) {
              e.splice(t - 1, 3, r);
              continue;
            }
            e[t++] = "+";
          }
          t++;
        }
      })(r),
      new m(r)
    );
  }
  function o(e, t) {
    t instanceof m
      ? e.push(...t._items)
      : t instanceof p
      ? e.push(t)
      : e.push(
          "number" == typeof (t = t) || "boolean" == typeof t || null === t
            ? t
            : n(Array.isArray(t) ? t.join(",") : t)
        );
  }
  function $(e, t) {
    return t.emptyStr() ? e : e.emptyStr() ? t : f`${e}${t}`;
  }
  function g(e) {
    return new m(n(e));
  }
  function n(e) {
    return JSON.stringify(e)
      .replace(/\u2028/g, "\\u2028")
      .replace(/\u2029/g, "\\u2029");
  }
  function w(e) {
    return "string" == typeof e && t.test(e) ? new m(`.${e}`) : v`[${e}]`;
  }
  class c extends Error {
    constructor(e) {
      super(`CodeGen: "code" for ${e} not defined`), (this.value = e.value);
    }
  }
  var d, b;
  ((Kr = d = d || {})[(Kr.Started = 0)] = "Started"),
    (Kr[(Kr.Completed = 1)] = "Completed");
  const h = { const: new p("const"), let: new p("let"), var: new p("var") };
  class s {
    constructor({ prefixes: e, parent: t } = {}) {
      (this._names = {}), (this._prefixes = e), (this._parent = t);
    }
    toName(e) {
      return e instanceof p ? e : this.name(e);
    }
    name(e) {
      return new p(this._newName(e));
    }
    _newName(e) {
      const t = this._names[e] || this._nameGroup(e);
      return `${e}${t.index++}`;
    }
    _nameGroup(e) {
      var t;
      if (
        (null !==
          (t =
            null === (t = this._parent) || void 0 === t
              ? void 0
              : t._prefixes) &&
          void 0 !== t &&
          t.has(e)) ||
        (this._prefixes && !this._prefixes.has(e))
      )
        throw new Error(`CodeGen: prefix "${e}" is not allowed in this scope`);
      return (this._names[e] = { prefix: e, index: 0 });
    }
  }
  class i extends p {
    constructor(e, t) {
      super(t), (this.prefix = e);
    }
    setValue(e, { property: t, itemIndex: r }) {
      (this.value = e), (this.scopePath = v`.${new p(t)}[${r}]`);
    }
  }
  const l = v`\n`;
  class u extends s {
    constructor(e) {
      super(e),
        (this._values = {}),
        (this._scope = e.scope),
        (this.opts = { ...e, _n: e.lines ? l : y });
    }
    get() {
      return this._scope;
    }
    name(e) {
      return new i(e, this._newName(e));
    }
    value(e, t) {
      if (void 0 === t.ref)
        throw new Error("CodeGen: ref must be passed in value");
      const r = this.toName(e);
      var { prefix: s } = r,
        e = null !== (o = t.key) && void 0 !== o ? o : t.ref;
      let a = this._values[s];
      if (a) {
        var o = a.get(e);
        if (o) return o;
      } else a = this._values[s] = new Map();
      a.set(e, r);
      const n = this._scope[s] || (this._scope[s] = []);
      e = n.length;
      return (n[e] = t.ref), r.setValue(t, { property: s, itemIndex: e }), r;
    }
    getValue(e, t) {
      const r = this._values[e];
      if (r) return r.get(t);
    }
    scopeRefs(t, e = this._values) {
      return this._reduceValues(e, (e) => {
        if (void 0 === e.scopePath)
          throw new Error(`CodeGen: name "${e}" has no value`);
        return v`${t}${e.scopePath}`;
      });
    }
    scopeCode(e = this._values, t, r) {
      return this._reduceValues(
        e,
        (e) => {
          if (void 0 === e.value)
            throw new Error(`CodeGen: name "${e}" has no value`);
          return e.value.code;
        },
        t,
        r
      );
    }
    _reduceValues(e, s, t = {}, a) {
      let o = y;
      for (const r in e) {
        const n = e[r];
        if (n) {
          const i = (t[r] = t[r] || new Map());
          n.forEach((t) => {
            if (!i.has(t)) {
              i.set(t, d.Started);
              let e = s(t);
              if (e) {
                var r = this.opts.es5 ? h.var : h.const;
                o = v`${o}${r} ${t} = ${e};${this.opts._n}`;
              } else {
                if (!(e = null == a ? void 0 : a(t))) throw new c(t);
                o = v`${o}${e}${this.opts._n}`;
              }
              i.set(t, d.Completed);
            }
          });
        }
      }
      return o;
    }
  }
  const E = {
    GT: new m(">"),
    GTE: new m(">="),
    LT: new m("<"),
    LTE: new m("<="),
    EQ: new m("==="),
    NEQ: new m("!=="),
    NOT: new m("!"),
    OR: new m("||"),
    AND: new m("&&"),
    ADD: new m("+"),
  };
  class S {
    optimizeNodes() {
      return this;
    }
    optimizeNames(e, t) {
      return this;
    }
  }
  class k extends S {
    constructor(e, t, r) {
      super(), (this.varKind = e), (this.name = t), (this.rhs = r);
    }
    render({ es5: e, _n: t }) {
      var r = e ? h.var : this.varKind,
        e = void 0 === this.rhs ? "" : ` = ${this.rhs}`;
      return `${r} ${this.name}${e};` + t;
    }
    optimizeNames(e, t) {
      if (e[this.name.str])
        return this.rhs && (this.rhs = J(this.rhs, e, t)), this;
    }
    get names() {
      return this.rhs instanceof r ? this.rhs.names : {};
    }
  }
  class _ extends S {
    constructor(e, t, r) {
      super(), (this.lhs = e), (this.rhs = t), (this.sideEffects = r);
    }
    render({ _n: e }) {
      return `${this.lhs} = ${this.rhs};` + e;
    }
    optimizeNames(e, t) {
      if (!(this.lhs instanceof p) || e[this.lhs.str] || this.sideEffects)
        return (this.rhs = J(this.rhs, e, t)), this;
    }
    get names() {
      return W(this.lhs instanceof p ? {} : { ...this.lhs.names }, this.rhs);
    }
  }
  class P extends _ {
    constructor(e, t, r, s) {
      super(e, r, s), (this.op = t);
    }
    render({ _n: e }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + e;
    }
  }
  class j extends S {
    constructor(e) {
      super(), (this.label = e), (this.names = {});
    }
    render({ _n: e }) {
      return `${this.label}:` + e;
    }
  }
  class N extends S {
    constructor(e) {
      super(), (this.label = e), (this.names = {});
    }
    render({ _n: e }) {
      return `break${this.label ? ` ${this.label}` : ""};` + e;
    }
  }
  class x extends S {
    constructor(e) {
      super(), (this.error = e);
    }
    render({ _n: e }) {
      return `throw ${this.error};` + e;
    }
    get names() {
      return this.error.names;
    }
  }
  class C extends S {
    constructor(e) {
      super(), (this.code = e);
    }
    render({ _n: e }) {
      return `${this.code};` + e;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(e, t) {
      return (this.code = J(this.code, e, t)), this;
    }
    get names() {
      return this.code instanceof r ? this.code.names : {};
    }
  }
  class A extends S {
    constructor(e = []) {
      super(), (this.nodes = e);
    }
    render(r) {
      return this.nodes.reduce((e, t) => e + t.render(r), "");
    }
    optimizeNodes() {
      const { nodes: e } = this;
      let t = e.length;
      for (; t--; ) {
        var r = e[t].optimizeNodes();
        Array.isArray(r)
          ? e.splice(t, 1, ...r)
          : r
          ? (e[t] = r)
          : e.splice(t, 1);
      }
      return 0 < e.length ? this : void 0;
    }
    optimizeNames(e, t) {
      const { nodes: r } = this;
      let s = r.length;
      for (; s--; ) {
        const a = r[s];
        a.optimizeNames(e, t) ||
          ((function (e, t) {
            for (const r in t) e[r] = (e[r] || 0) - (t[r] || 0);
          })(e, a.names),
          r.splice(s, 1));
      }
      return 0 < r.length ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((e, t) => H(e, t.names), {});
    }
  }
  class I extends A {
    render(e) {
      return "{" + e._n + super.render(e) + "}" + e._n;
    }
  }
  class T extends A {}
  class R extends I {}
  R.kind = "else";
  class O extends I {
    constructor(e, t) {
      super(t), (this.condition = e);
    }
    render(e) {
      let t = `if(${this.condition})` + super.render(e);
      return this.else && (t += "else " + this.else.render(e)), t;
    }
    optimizeNodes() {
      super.optimizeNodes();
      var e,
        t = this.condition;
      if (!0 === t) return this.nodes;
      let r = this.else;
      return (
        r &&
          ((e = r.optimizeNodes()),
          (r = this.else = Array.isArray(e) ? new R(e) : e)),
        r
          ? !1 === t
            ? r instanceof O
              ? r
              : r.nodes
            : this.nodes.length
            ? this
            : new O(B(t), r instanceof O ? [r] : r.nodes)
          : !1 !== t && this.nodes.length
          ? this
          : void 0
      );
    }
    optimizeNames(e, t) {
      var r;
      if (
        ((this.else =
          null === (r = this.else) || void 0 === r
            ? void 0
            : r.optimizeNames(e, t)),
        super.optimizeNames(e, t) || this.else)
      )
        return (this.condition = J(this.condition, e, t)), this;
    }
    get names() {
      var e = super.names;
      return W(e, this.condition), this.else && H(e, this.else.names), e;
    }
  }
  O.kind = "if";
  class D extends I {}
  D.kind = "for";
  class q extends D {
    constructor(e) {
      super(), (this.iteration = e);
    }
    render(e) {
      return `for(${this.iteration})` + super.render(e);
    }
    optimizeNames(e, t) {
      if (super.optimizeNames(e, t))
        return (this.iteration = J(this.iteration, e, t)), this;
    }
    get names() {
      return H(super.names, this.iteration.names);
    }
  }
  class z extends D {
    constructor(e, t, r, s) {
      super(),
        (this.varKind = e),
        (this.name = t),
        (this.from = r),
        (this.to = s);
    }
    render(e) {
      var { name: t, from: r, to: s } = this;
      return (
        `for(${e.es5 ? h.var : this.varKind} ${t}=${r}; ${t}<${s}; ${t}++)` +
        super.render(e)
      );
    }
    get names() {
      var e = W(super.names, this.from);
      return W(e, this.to);
    }
  }
  class V extends D {
    constructor(e, t, r, s) {
      super(),
        (this.loop = e),
        (this.varKind = t),
        (this.name = r),
        (this.iterable = s);
    }
    render(e) {
      return (
        `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` +
        super.render(e)
      );
    }
    optimizeNames(e, t) {
      if (super.optimizeNames(e, t))
        return (this.iterable = J(this.iterable, e, t)), this;
    }
    get names() {
      return H(super.names, this.iterable.names);
    }
  }
  class F extends I {
    constructor(e, t, r) {
      super(), (this.name = e), (this.args = t), (this.async = r);
    }
    render(e) {
      return (
        `${this.async ? "async " : ""}function ${this.name}(${this.args})` +
        super.render(e)
      );
    }
  }
  F.kind = "func";
  class L extends A {
    render(e) {
      return "return " + super.render(e);
    }
  }
  L.kind = "return";
  class U extends I {
    render(e) {
      let t = "try" + super.render(e);
      return (
        this.catch && (t += this.catch.render(e)),
        this.finally && (t += this.finally.render(e)),
        t
      );
    }
    optimizeNodes() {
      var e;
      return (
        super.optimizeNodes(),
        null !== (e = this.catch) && void 0 !== e && e.optimizeNodes(),
        null !== (e = this.finally) && void 0 !== e && e.optimizeNodes(),
        this
      );
    }
    optimizeNames(e, t) {
      var r;
      return (
        super.optimizeNames(e, t),
        null !== (r = this.catch) && void 0 !== r && r.optimizeNames(e, t),
        null !== (r = this.finally) && void 0 !== r && r.optimizeNames(e, t),
        this
      );
    }
    get names() {
      var e = super.names;
      return (
        this.catch && H(e, this.catch.names),
        this.finally && H(e, this.finally.names),
        e
      );
    }
  }
  class M extends I {
    constructor(e) {
      super(), (this.error = e);
    }
    render(e) {
      return `catch(${this.error})` + super.render(e);
    }
  }
  M.kind = "catch";
  class K extends I {
    render(e) {
      return "finally" + super.render(e);
    }
  }
  K.kind = "finally";
  class G {
    constructor(e, t = {}) {
      (this._values = {}),
        (this._blockStarts = []),
        (this._constants = {}),
        (this.opts = { ...t, _n: t.lines ? "\n" : "" }),
        (this._extScope = e),
        (this._scope = new s({ parent: e })),
        (this._nodes = [new T()]);
    }
    toString() {
      return this._root.render(this.opts);
    }
    name(e) {
      return this._scope.name(e);
    }
    scopeName(e) {
      return this._extScope.name(e);
    }
    scopeValue(e, t) {
      t = this._extScope.value(e, t);
      const r = this._values[t.prefix] || (this._values[t.prefix] = new Set());
      return r.add(t), t;
    }
    getScopeValue(e, t) {
      return this._extScope.getValue(e, t);
    }
    scopeRefs(e) {
      return this._extScope.scopeRefs(e, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(e, t, r, s) {
      t = this._scope.toName(t);
      return (
        void 0 !== r && s && (this._constants[t.str] = r),
        this._leafNode(new k(e, t, r)),
        t
      );
    }
    const(e, t, r) {
      return this._def(h.const, e, t, r);
    }
    let(e, t, r) {
      return this._def(h.let, e, t, r);
    }
    var(e, t, r) {
      return this._def(h.var, e, t, r);
    }
    assign(e, t, r) {
      return this._leafNode(new _(e, t, r));
    }
    add(e, t) {
      return this._leafNode(new P(e, E.ADD, t));
    }
    code(e) {
      return (
        "function" == typeof e ? e() : e !== y && this._leafNode(new C(e)), this
      );
    }
    object(...e) {
      const t = ["{"];
      for (var [r, s] of e)
        1 < t.length && t.push(","),
          t.push(r),
          (r === s && !this.opts.es5) || (t.push(":"), o(t, s));
      return t.push("}"), new m(t);
    }
    if(e, t, r) {
      if ((this._blockNode(new O(e)), t && r))
        this.code(t).else().code(r).endIf();
      else if (t) this.code(t).endIf();
      else if (r) throw new Error('CodeGen: "else" body without "then" body');
      return this;
    }
    elseIf(e) {
      return this._elseNode(new O(e));
    }
    else() {
      return this._elseNode(new R());
    }
    endIf() {
      return this._endBlockNode(O, R);
    }
    _for(e, t) {
      return this._blockNode(e), t && this.code(t).endFor(), this;
    }
    for(e, t) {
      return this._for(new q(e), t);
    }
    forRange(e, t, r, s, a = this.opts.es5 ? h.var : h.let) {
      const o = this._scope.toName(e);
      return this._for(new z(a, o, t, r), () => s(o));
    }
    forOf(e, t, r, s = h.const) {
      const a = this._scope.toName(e);
      if (this.opts.es5) {
        const o = t instanceof p ? t : this.var("_arr", t);
        return this.forRange("_i", 0, v`${o}.length`, (e) => {
          this.var(a, v`${o}[${e}]`), r(a);
        });
      }
      return this._for(new V("of", s, a, t), () => r(a));
    }
    forIn(e, t, r, s = this.opts.es5 ? h.var : h.const) {
      if (this.opts.ownProperties)
        return this.forOf(e, v`Object.keys(${t})`, r);
      const a = this._scope.toName(e);
      return this._for(new V("in", s, a, t), () => r(a));
    }
    endFor() {
      return this._endBlockNode(D);
    }
    label(e) {
      return this._leafNode(new j(e));
    }
    break(e) {
      return this._leafNode(new N(e));
    }
    return(e) {
      var t = new L();
      if ((this._blockNode(t), this.code(e), 1 !== t.nodes.length))
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(L);
    }
    try(e, t, r) {
      if (!t && !r)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const s = new U();
      return (
        this._blockNode(s),
        this.code(e),
        t &&
          ((e = this.name("e")), (this._currNode = s.catch = new M(e)), t(e)),
        r && ((this._currNode = s.finally = new K()), this.code(r)),
        this._endBlockNode(M, K)
      );
    }
    throw(e) {
      return this._leafNode(new x(e));
    }
    block(e, t) {
      return (
        this._blockStarts.push(this._nodes.length),
        e && this.code(e).endBlock(t),
        this
      );
    }
    endBlock(e) {
      var t = this._blockStarts.pop();
      if (void 0 === t) throw new Error("CodeGen: not in self-balancing block");
      var r = this._nodes.length - t;
      if (r < 0 || (void 0 !== e && r !== e))
        throw new Error(
          `CodeGen: wrong number of nodes: ${r} vs ${e} expected`
        );
      return (this._nodes.length = t), this;
    }
    func(e, t = y, r, s) {
      return this._blockNode(new F(e, t, r)), s && this.code(s).endFunc(), this;
    }
    endFunc() {
      return this._endBlockNode(F);
    }
    optimize(e = 1) {
      for (; 0 < e--; )
        this._root.optimizeNodes(),
          this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(e) {
      return this._currNode.nodes.push(e), this;
    }
    _blockNode(e) {
      this._currNode.nodes.push(e), this._nodes.push(e);
    }
    _endBlockNode(e, t) {
      var r = this._currNode;
      if (r instanceof e || (t && r instanceof t))
        return this._nodes.pop(), this;
      throw new Error(
        `CodeGen: not in block "${t ? `${e.kind}/${t.kind}` : e.kind}"`
      );
    }
    _elseNode(e) {
      const t = this._currNode;
      if (!(t instanceof O)) throw new Error('CodeGen: "else" without "if"');
      return (this._currNode = t.else = e), this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      var e = this._nodes;
      return e[e.length - 1];
    }
    set _currNode(e) {
      const t = this._nodes;
      t[t.length - 1] = e;
    }
  }
  function H(e, t) {
    for (const r in t) e[r] = (e[r] || 0) + (t[r] || 0);
    return e;
  }
  function W(e, t) {
    return t instanceof r ? H(e, t.names) : e;
  }
  function J(e, r, s) {
    return e instanceof p
      ? a(e)
      : (t = e) instanceof m &&
        t._items.some(
          (e) => e instanceof p && 1 === r[e.str] && void 0 !== s[e.str]
        )
      ? new m(
          e._items.reduce(
            (e, t) => (
              (t = t instanceof p ? a(t) : t) instanceof m
                ? e.push(...t._items)
                : e.push(t),
              e
            ),
            []
          )
        )
      : e;
    var t;
    function a(e) {
      var t = s[e.str];
      return void 0 === t || 1 !== r[e.str] ? e : (delete r[e.str], t);
    }
  }
  function B(e) {
    return "boolean" == typeof e || "number" == typeof e || null === e
      ? !e
      : v`!${te(e)}`;
  }
  const Q = ee(E.AND);
  function Z(...e) {
    return e.reduce(Q);
  }
  const Y = ee(E.OR);
  function X(...e) {
    return e.reduce(Y);
  }
  function ee(r) {
    return (e, t) => (e === y ? t : t === y ? e : v`${te(e)} ${r} ${te(t)}`);
  }
  function te(e) {
    return e instanceof p ? e : v`(${e})`;
  }
  function re(e) {
    const t = {};
    for (const r of e) t[r] = !0;
    return t;
  }
  function se(e, t) {
    return "boolean" == typeof t
      ? t
      : 0 === Object.keys(t).length ||
          (ae(e, t),
          !(function (e, t) {
            if ("boolean" == typeof e) return !e;
            for (const r in e) if (t[r]) return !0;
            return !1;
          })(t, e.self.RULES.all));
  }
  function ae(e, t = e.schema) {
    var { opts: r, self: s } = e;
    if (r.strictSchema && "boolean" != typeof t) {
      var a = s.RULES.keywords;
      for (const o in t) a[o] || ve(e, `unknown keyword: "${o}"`);
    }
  }
  function oe(e, t) {
    if ("boolean" == typeof e) return !e;
    for (const r in e) if ("$ref" !== r && t.all[r]) return 1;
  }
  function ne({ topSchemaRef: e, schemaPath: t }, r, s, a) {
    if (!a) {
      if ("number" == typeof r || "boolean" == typeof r) return r;
      if ("string" == typeof r) return v`${r}`;
    }
    return v`${e}${t}${w(s)}`;
  }
  function ie(e) {
    return "number" == typeof e
      ? `${e}`
      : e.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function ce(e) {
    return e.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  function de(e, t) {
    if (Array.isArray(e)) for (const r of e) t(r);
    else t(e);
  }
  function he({
    mergeNames: a,
    mergeToName: o,
    mergeValues: n,
    resultToName: i,
  }) {
    return (e, t, r, s) => {
      r =
        void 0 === r
          ? t
          : r instanceof p
          ? ((t instanceof p ? a : o)(e, t, r), r)
          : t instanceof p
          ? (o(e, r, t), t)
          : n(t, r);
      return s !== p || r instanceof p ? r : i(e, r);
    };
  }
  const le = {
    props: he({
      mergeNames: (e, t, r) =>
        e.if(v`${r} !== true && ${t} !== undefined`, () => {
          e.if(
            v`${t} === true`,
            () => e.assign(r, !0),
            () => e.assign(r, v`${r} || {}`).code(v`Object.assign(${r}, ${t})`)
          );
        }),
      mergeToName: (e, t, r) =>
        e.if(v`${r} !== true`, () => {
          !0 === t
            ? e.assign(r, !0)
            : (e.assign(r, v`${r} || {}`), pe(e, r, t));
        }),
      mergeValues: (e, t) => !0 === e || { ...e, ...t },
      resultToName: ue,
    }),
    items: he({
      mergeNames: (e, t, r) =>
        e.if(v`${r} !== true && ${t} !== undefined`, () =>
          e.assign(r, v`${t} === true ? true : ${r} > ${t} ? ${r} : ${t}`)
        ),
      mergeToName: (e, t, r) =>
        e.if(v`${r} !== true`, () =>
          e.assign(r, !0 === t || v`${r} > ${t} ? ${r} : ${t}`)
        ),
      mergeValues: (e, t) => !0 === e || Math.max(e, t),
      resultToName: (e, t) => e.var("items", t),
    }),
  };
  function ue(e, t) {
    if (!0 === t) return e.var("props", !0);
    var r = e.var("props", v`{}`);
    return void 0 !== t && pe(e, r, t), r;
  }
  function pe(t, r, e) {
    Object.keys(e).forEach((e) => t.assign(v`${r}${w(e)}`, !0));
  }
  const me = {};
  function fe(e, t) {
    return e.scopeValue("func", {
      ref: t,
      code: me[t.code] || (me[t.code] = new m(t.code)),
    });
  }
  function ye(e, t, r) {
    if (e instanceof p) {
      t = t === b.Num;
      return r
        ? t
          ? v`"[" + ${e} + "]"`
          : v`"['" + ${e} + "']"`
        : t
        ? v`"/" + ${e}`
        : v`"/" + ${e}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return r ? w(e).toString() : "/" + ie(e);
  }
  function ve(e, t, r = e.opts.strictSchema) {
    if (r) {
      if (((t = `strict mode: ${t}`), !0 === r)) throw new Error(t);
      e.self.logger.warn(t);
    }
  }
  ((ns = b = b || {})[(ns.Num = 0)] = "Num"), (ns[(ns.Str = 1)] = "Str");
  const $e = {
      data: new p("data"),
      valCxt: new p("valCxt"),
      instancePath: new p("instancePath"),
      parentData: new p("parentData"),
      parentDataProperty: new p("parentDataProperty"),
      rootData: new p("rootData"),
      dynamicAnchors: new p("dynamicAnchors"),
      vErrors: new p("vErrors"),
      errors: new p("errors"),
      this: new p("this"),
      self: new p("self"),
      scope: new p("scope"),
      json: new p("json"),
      jsonPos: new p("jsonPos"),
      jsonLen: new p("jsonLen"),
      jsonPart: new p("jsonPart"),
    },
    ge = {
      message: ({ keyword: e }) => f`should pass "${e}" keyword validation`,
    },
    we = {
      message: ({ keyword: e, schemaType: t }) =>
        t
          ? f`"${e}" keyword must be ${t} ($data)`
          : f`"${e}" keyword is invalid ($data)`,
    };
  function be(e, t = ge, r, s) {
    var { it: a } = e,
      { gen: o, compositeRule: n, allErrors: i } = a,
      r = _e(e, t, r);
    (null != s ? s : n || i) ? Ee(o, r) : Se(a, v`[${r}]`);
  }
  function Ee(e, t) {
    const r = e.const("err", t);
    e.if(
      v`${$e.vErrors} === null`,
      () => e.assign($e.vErrors, v`[${r}]`),
      v`${$e.vErrors}.push(${r})`
    ),
      e.code(v`${$e.errors}++`);
  }
  function Se(e, t) {
    const { gen: r, validateName: s, schemaEnv: a } = e;
    a.$async
      ? r.throw(v`new ${e.ValidationError}(${t})`)
      : (r.assign(v`${s}.errors`, t), r.return(!1));
  }
  const ke = {
    keyword: new p("keyword"),
    schemaPath: new p("schemaPath"),
    params: new p("params"),
    propertyName: new p("propertyName"),
    message: new p("message"),
    schema: new p("schema"),
    parentSchema: new p("parentSchema"),
  };
  function _e(e, t, r) {
    var { createErrors: s } = e.it;
    return !1 === s
      ? v`{}`
      : (function (e, t, r = {}) {
          const { gen: s, it: a } = e,
            o = [
              (function ({ errorPath: e }, { instancePath: t }) {
                e = t ? f`${e}${ye(t, b.Str)}` : e;
                return [$e.instancePath, $($e.instancePath, e)];
              })(a, r),
              (function (
                { keyword: e, it: { errSchemaPath: t } },
                { schemaPath: r, parentSchema: s }
              ) {
                let a = s ? t : f`${t}/${e}`;
                r && (a = f`${a}${ye(r, b.Str)}`);
                return [ke.schemaPath, a];
              })(e, r),
            ];
          return (
            (function (e, { params: t, message: r }, s) {
              var { keyword: a, data: o, schemaValue: n, it: i } = e,
                {
                  opts: c,
                  propertyName: d,
                  topSchemaRef: h,
                  schemaPath: i,
                } = i;
              s.push(
                [ke.keyword, a],
                [ke.params, "function" == typeof t ? t(e) : t || v`{}`]
              ),
                c.messages &&
                  s.push([ke.message, "function" == typeof r ? r(e) : r]);
              c.verbose &&
                s.push(
                  [ke.schema, n],
                  [ke.parentSchema, v`${h}${i}`],
                  [$e.data, o]
                );
              d && s.push([ke.propertyName, d]);
            })(e, t, o),
            s.object(...o)
          );
        })(e, t, r);
  }
  const Pe = { message: "boolean schema is false" };
  function je(e, t) {
    var { gen: r, data: s } = e;
    be(
      {
        gen: r,
        keyword: "false schema",
        data: s,
        schema: !1,
        schemaCode: !1,
        schemaValue: !1,
        params: {},
        it: e,
      },
      Pe,
      void 0,
      t
    );
  }
  var Ne;
  const xe = new Set([
    "string",
    "number",
    "integer",
    "boolean",
    "null",
    "object",
    "array",
  ]);
  function Ce(e) {
    return "string" == typeof e && xe.has(e);
  }
  function Ae(t, e) {
    return e.rules.some((e) => Ie(t, e));
  }
  function Ie(t, e) {
    return (
      void 0 !== t[e.keyword] ||
      (null === (e = e.definition.implements) || void 0 === e
        ? void 0
        : e.some((e) => void 0 !== t[e]))
    );
  }
  function Te(e) {
    const t = Re(e.type);
    if (t.includes("null")) {
      if (!1 === e.nullable)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!t.length && void 0 !== e.nullable)
        throw new Error('"nullable" cannot be used without "type"');
      !0 === e.nullable && t.push("null");
    }
    return t;
  }
  function Re(e) {
    const t = Array.isArray(e) ? e : e ? [e] : [];
    if (t.every(Ce)) return t;
    throw new Error("type must be JSONType or JSONType[]: " + t.join(","));
  }
  function Oe(e, t) {
    const { gen: r, data: s, opts: a } = e,
      o =
        ((c = t),
        (n = a.coerceTypes)
          ? c.filter((e) => De.has(e) || ("array" === n && "array" === e))
          : []);
    var n,
      i,
      c,
      d,
      i =
        0 < t.length &&
        !(
          0 === o.length &&
          1 === t.length &&
          (([{ schema: i, self: c }, d] = [e, t[0]]),
          (d = c.RULES.types[d]) && !0 !== d && Ae(i, d))
        );
    return (
      i &&
        ((d = ze(t, s, a.strictNumbers, Ne.Wrong)),
        r.if(d, () => {
          o.length
            ? (function (a, e, t) {
                const { gen: o, data: n, opts: r } = a,
                  s = o.let("dataType", v`typeof ${n}`),
                  i = o.let("coerced", v`undefined`);
                "array" === r.coerceTypes &&
                  o.if(
                    v`${s} == 'object' && Array.isArray(${n}) && ${n}.length == 1`,
                    () =>
                      o
                        .assign(n, v`${n}[0]`)
                        .assign(s, v`typeof ${n}`)
                        .if(ze(e, n, r.strictNumbers), () => o.assign(i, n))
                  );
                o.if(v`${i} !== undefined`);
                for (const c of t)
                  (De.has(c) || ("array" === c && "array" === r.coerceTypes)) &&
                    (function (e) {
                      switch (e) {
                        case "string":
                          return o
                            .elseIf(v`${s} == "number" || ${s} == "boolean"`)
                            .assign(i, v`"" + ${n}`)
                            .elseIf(v`${n} === null`)
                            .assign(i, v`""`);
                        case "number":
                          return o
                            .elseIf(
                              v`${s} == "boolean" || ${n} === null
              || (${s} == "string" && ${n} && ${n} == +${n})`
                            )
                            .assign(i, v`+${n}`);
                        case "integer":
                          return o
                            .elseIf(
                              v`${s} === "boolean" || ${n} === null
              || (${s} === "string" && ${n} && ${n} == +${n} && !(${n} % 1))`
                            )
                            .assign(i, v`+${n}`);
                        case "boolean":
                          return o
                            .elseIf(
                              v`${n} === "false" || ${n} === 0 || ${n} === null`
                            )
                            .assign(i, !1)
                            .elseIf(v`${n} === "true" || ${n} === 1`)
                            .assign(i, !0);
                        case "null":
                          return (
                            o.elseIf(
                              v`${n} === "" || ${n} === 0 || ${n} === false`
                            ),
                            o.assign(i, null)
                          );
                        case "array":
                          o.elseIf(
                            v`${s} === "string" || ${s} === "number"
              || ${s} === "boolean" || ${n} === null`
                          ).assign(i, v`[${n}]`);
                      }
                    })(c);
                o.else(),
                  Fe(a),
                  o.endIf(),
                  o.if(v`${i} !== undefined`, () => {
                    var e, t, r, s;
                    o.assign(n, i),
                      ([{ gen: e, parentData: t, parentDataProperty: r }, s] = [
                        a,
                        i,
                      ]),
                      e.if(v`${t} !== undefined`, () =>
                        e.assign(v`${t}[${r}]`, s)
                      );
                  });
              })(e, t, o)
            : Fe(e);
        })),
      i
    );
  }
  ((ds = Ne = Ne || {})[(ds.Correct = 0)] = "Correct"),
    (ds[(ds.Wrong = 1)] = "Wrong");
  const De = new Set(["string", "number", "integer", "boolean", "null"]);
  function qe(e, t, r, s = Ne.Correct) {
    var a = s === Ne.Correct ? E.EQ : E.NEQ;
    let o;
    switch (e) {
      case "null":
        return v`${t} ${a} null`;
      case "array":
        o = v`Array.isArray(${t})`;
        break;
      case "object":
        o = v`${t} && typeof ${t} == "object" && !Array.isArray(${t})`;
        break;
      case "integer":
        o = n(v`!(${t} % 1) && !isNaN(${t})`);
        break;
      case "number":
        o = n();
        break;
      default:
        return v`typeof ${t} ${a} ${e}`;
    }
    return s === Ne.Correct ? o : B(o);
    function n(e = y) {
      return Z(v`typeof ${t} == "number"`, e, r ? v`isFinite(${t})` : y);
    }
  }
  function ze(e, t, r, s) {
    if (1 === e.length) return qe(e[0], t, r, s);
    let a;
    const o = re(e);
    o.array && o.object
      ? ((e = v`typeof ${t} != "object"`),
        (a = o.null ? e : v`!${t} || ${e}`),
        delete o.null,
        delete o.array,
        delete o.object)
      : (a = y),
      o.number && delete o.integer;
    for (const n in o) a = Z(a, qe(n, t, r, s));
    return a;
  }
  const Ve = {
    message: ({ schema: e }) => `must be ${e}`,
    params: ({ schema: e, schemaValue: t }) =>
      "string" == typeof e ? v`{type: ${e}}` : v`{type: ${t}}`,
  };
  function Fe(e) {
    be(
      (function (e) {
        var { gen: t, data: r, schema: s } = e,
          a = ne(e, s, "type");
        return {
          gen: t,
          keyword: "type",
          data: r,
          schema: s.type,
          schemaCode: a,
          schemaValue: a,
          parentSchema: s,
          params: {},
          it: e,
        };
      })(e),
      Ve
    );
  }
  function Le(e, t, r) {
    const { gen: s, compositeRule: a, data: o, opts: n } = e;
    if (void 0 !== r) {
      t = v`${o}${w(t)}`;
      if (a) ve(e, `default is ignored for: ${t}`);
      else {
        let e = v`${t} === undefined`;
        "empty" === n.useDefaults &&
          (e = v`${e} || ${t} === null || ${t} === ""`),
          s.if(e, v`${t} = ${g(r)}`);
      }
    }
  }
  function Ue(e, t) {
    const { gen: r, data: s, it: a } = e;
    r.if(We(r, s, t, a.opts.ownProperties), () => {
      e.setParams({ missingProperty: v`${t}` }, !0), e.error();
    });
  }
  function Me({ gen: t, data: r, it: { opts: s } }, e, a) {
    return X(...e.map((e) => Z(We(t, r, e, s.ownProperties), v`${a} = ${e}`)));
  }
  function Ke(e, t) {
    e.setParams({ missingProperty: t }, !0), e.error();
  }
  function Ge(e, t, r) {
    return v`${
      ((e = e),
      e.scopeValue("func", {
        ref: Object.prototype.hasOwnProperty,
        code: v`Object.prototype.hasOwnProperty`,
      }))
    }.call(${t}, ${r})`;
  }
  function He(e, t, r, s) {
    var a = v`${t}${w(r)} !== undefined`;
    return s ? v`${a} && ${Ge(e, t, r)}` : a;
  }
  function We(e, t, r, s) {
    var a = v`${t}${w(r)} === undefined`;
    return s ? X(a, B(Ge(e, t, r))) : a;
  }
  function Je(e) {
    return e ? Object.keys(e).filter((e) => "__proto__" !== e) : [];
  }
  function Be(
    {
      schemaCode: e,
      data: t,
      it: { gen: r, topSchemaRef: s, schemaPath: a, errorPath: o },
      it: n,
    },
    i,
    c,
    d
  ) {
    t = d ? v`${e}, ${t}, ${s}${a}` : t;
    const h = [
      [$e.instancePath, $($e.instancePath, o)],
      [$e.parentData, n.parentData],
      [$e.parentDataProperty, n.parentDataProperty],
      [$e.rootData, $e.rootData],
    ];
    n.opts.dynamicRef && h.push([$e.dynamicAnchors, $e.dynamicAnchors]);
    r = v`${t}, ${r.object(...h)}`;
    return c !== y ? v`${i}.call(${c}, ${r})` : v`${i}(${r})`;
  }
  function Qe({ gen: e, it: { opts: t } }, r) {
    t = t.unicodeRegExp ? "u" : "";
    return e.scopeValue("pattern", {
      key: r,
      ref: new RegExp(r, t),
      code: v`new RegExp(${r}, ${t})`,
    });
  }
  function Ze(r) {
    const { gen: s, data: a, keyword: o, it: e } = r,
      n = s.name("valid");
    if (e.allErrors) {
      const i = s.let("valid", !0);
      return t(() => s.assign(i, !1)), i;
    }
    return s.var(n, !0), t(() => s.break()), n;
    function t(t) {
      var e = s.const("len", v`${a}.length`);
      s.forRange("i", 0, e, (e) => {
        r.subschema({ keyword: o, dataProp: e, dataPropType: b.Num }, n),
          s.if(B(n), t);
      });
    }
  }
  function Ye(s, a) {
    const {
      gen: o,
      keyword: e,
      schema: t,
      parentSchema: r,
      $data: n,
      it: i,
    } = s;
    !(function ({ schemaEnv: e }, t) {
      if (t.async && !e.$async) throw new Error("async keyword in sync schema");
    })(i, a);
    var c = !n && a.compile ? a.compile.call(i.self, t, r, i) : a.validate;
    const d = et(o, e, c),
      h = o.let("valid");
    function l(e = a.async ? v`await ` : y) {
      var t = i.opts.passContext ? $e.this : $e.self,
        r = !(("compile" in a && !n) || !1 === a.schema);
      o.assign(h, v`${e}${Be(s, d, t, r)}`, a.modifying);
    }
    function u(e) {
      var t;
      o.if(B(null !== (t = a.valid) && void 0 !== t ? t : h), e);
    }
    s.block$data(h, function () {
      if (!1 === a.errors) l(), a.modifying && Xe(s), u(() => s.error());
      else {
        const e = (
          a.async
            ? function () {
                const t = o.let("ruleErrs", null);
                return (
                  o.try(
                    () => l(v`await `),
                    (e) =>
                      o.assign(h, !1).if(
                        v`${e} instanceof ${i.ValidationError}`,
                        () => o.assign(t, v`${e}.errors`),
                        () => o.throw(e)
                      )
                  ),
                  t
                );
              }
            : function () {
                var e = v`${d}.errors`;
                return o.assign(e, null), l(y), e;
              }
        )();
        a.modifying && Xe(s),
          u(() =>
            (function (e, t) {
              const { gen: r } = e;
              r.if(
                v`Array.isArray(${t})`,
                () => {
                  r
                    .assign(
                      $e.vErrors,
                      v`${$e.vErrors} === null ? ${t} : ${$e.vErrors}.concat(${t})`
                    )
                    .assign($e.errors, v`${$e.vErrors}.length`),
                    (function ({
                      gen: t,
                      keyword: r,
                      schemaValue: s,
                      data: a,
                      errsCount: e,
                      it: o,
                    }) {
                      if (void 0 === e)
                        throw new Error("ajv implementation error");
                      const n = t.name("err");
                      t.forRange("i", e, $e.errors, (e) => {
                        t.const(n, v`${$e.vErrors}[${e}]`),
                          t.if(v`${n}.instancePath === undefined`, () =>
                            t.assign(
                              v`${n}.instancePath`,
                              $($e.instancePath, o.errorPath)
                            )
                          ),
                          t.assign(
                            v`${n}.schemaPath`,
                            f`${o.errSchemaPath}/${r}`
                          ),
                          o.opts.verbose &&
                            (t.assign(v`${n}.schema`, s),
                            t.assign(v`${n}.data`, a));
                      });
                    })(e);
                },
                () => e.error()
              );
            })(s, e)
          );
      }
    }),
      s.ok(null !== (c = a.valid) && void 0 !== c ? c : h);
  }
  function Xe(e) {
    const { gen: t, data: r, it: s } = e;
    t.if(s.parentData, () =>
      t.assign(r, v`${s.parentData}[${s.parentDataProperty}]`)
    );
  }
  function et(e, t, r) {
    if (void 0 === r) throw new Error(`keyword "${t}" failed to compile`);
    return e.scopeValue(
      "keyword",
      "function" == typeof r ? { ref: r } : { ref: r, code: g(r) }
    );
  }
  function tt(
    e,
    {
      keyword: t,
      schemaProp: r,
      schema: s,
      schemaPath: a,
      errSchemaPath: o,
      topSchemaRef: n,
    }
  ) {
    if (void 0 !== t && void 0 !== s)
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    if (void 0 !== t) {
      var i = e.schema[t];
      return void 0 === r
        ? {
            schema: i,
            schemaPath: v`${e.schemaPath}${w(t)}`,
            errSchemaPath: `${e.errSchemaPath}/${t}`,
          }
        : {
            schema: i[r],
            schemaPath: v`${e.schemaPath}${w(t)}${w(r)}`,
            errSchemaPath: `${e.errSchemaPath}/${t}/${
              ((r = r), encodeURIComponent(ie(r)))
            }`,
          };
    }
    if (void 0 === s)
      throw new Error('either "keyword" or "schema" must be passed');
    if (void 0 === a || void 0 === o || void 0 === n)
      throw new Error(
        '"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"'
      );
    return { schema: s, schemaPath: a, topSchemaRef: n, errSchemaPath: o };
  }
  var rt = function e(t, r) {
      if (t === r) return !0;
      if (t && r && "object" == typeof t && "object" == typeof r) {
        if (t.constructor !== r.constructor) return !1;
        var s, a, o;
        if (Array.isArray(t)) {
          if ((s = t.length) != r.length) return !1;
          for (a = s; 0 != a--; ) if (!e(t[a], r[a])) return !1;
          return !0;
        }
        if (t.constructor === RegExp)
          return t.source === r.source && t.flags === r.flags;
        if (t.valueOf !== Object.prototype.valueOf)
          return t.valueOf() === r.valueOf();
        if (t.toString !== Object.prototype.toString)
          return t.toString() === r.toString();
        if ((s = (o = Object.keys(t)).length) !== Object.keys(r).length)
          return !1;
        for (a = s; 0 != a--; )
          if (!Object.prototype.hasOwnProperty.call(r, o[a])) return !1;
        for (a = s; 0 != a--; ) {
          var n = o[a];
          if (!e(t[n], r[n])) return !1;
        }
        return !0;
      }
      return t != t && r != r;
    },
    st = Object.freeze(Object.assign(Object.create(null), rt, { default: rt })),
    at = { exports: {} },
    ot = (at.exports = function (e, t, r) {
      "function" == typeof t && ((r = t), (t = {})),
        (function e(t, r, s, a, o, n, i, c, d, h) {
          if (a && "object" == typeof a && !Array.isArray(a)) {
            for (var l in (r(a, o, n, i, c, d, h), a)) {
              var u = a[l];
              if (Array.isArray(u)) {
                if (l in ot.arrayKeywords)
                  for (var p = 0; p < u.length; p++)
                    e(t, r, s, u[p], o + "/" + l + "/" + p, n, o, l, a, p);
              } else if (l in ot.propsKeywords) {
                if (u && "object" == typeof u)
                  for (var m in u)
                    e(t, r, s, u[m], o + "/" + l + "/" + nt(m), n, o, l, a, m);
              } else
                (l in ot.keywords || (t.allKeys && !(l in ot.skipKeywords))) &&
                  e(t, r, s, u, o + "/" + l, n, o, l, a);
            }
            s(a, o, n, i, c, d, h);
          }
        })(
          t,
          "function" == typeof (r = t.cb || r) ? r : r.pre || function () {},
          r.post || function () {},
          e,
          "",
          e
        );
    });
  function nt(e) {
    return e.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  (ot.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0,
    if: !0,
    then: !0,
    else: !0,
  }),
    (ot.arrayKeywords = { items: !0, allOf: !0, anyOf: !0, oneOf: !0 }),
    (ot.propsKeywords = {
      $defs: !0,
      definitions: !0,
      properties: !0,
      patternProperties: !0,
      dependencies: !0,
    }),
    (ot.skipKeywords = {
      default: !0,
      enum: !0,
      const: !0,
      required: !0,
      maximum: !0,
      minimum: !0,
      exclusiveMaximum: !0,
      exclusiveMinimum: !0,
      multipleOf: !0,
      maxLength: !0,
      minLength: !0,
      pattern: !0,
      format: !0,
      maxItems: !0,
      minItems: !0,
      uniqueItems: !0,
      maxProperties: !0,
      minProperties: !0,
    });
  var it,
    ct,
    dt,
    ht,
    lt,
    ut,
    pt,
    mt,
    ft,
    yt,
    vt,
    $t,
    gt,
    wt,
    bt,
    Et,
    St,
    kt,
    _t,
    Pt,
    jt,
    Nt,
    xt,
    Ct,
    At,
    It,
    Tt,
    Rt,
    Ot,
    Dt,
    qt = at.exports,
    zt = Object.freeze(
      Object.assign(Object.create(null), at.exports, { default: qt })
    ),
    Vt = { exports: {} };
  function Ft() {
    for (var e = arguments.length, t = Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    if (1 < t.length) {
      t[0] = t[0].slice(0, -1);
      for (var s = t.length - 1, a = 1; a < s; ++a) t[a] = t[a].slice(1, -1);
      return (t[s] = t[s].slice(1)), t.join("");
    }
    return t[0];
  }
  function Lt(e) {
    return "(?:" + e + ")";
  }
  function Ut(e) {
    return void 0 === e
      ? "undefined"
      : null === e
      ? "null"
      : Object.prototype.toString
          .call(e)
          .split(" ")
          .pop()
          .split("]")
          .shift()
          .toLowerCase();
  }
  function Mt(e) {
    return e.toUpperCase();
  }
  function Kt(e) {
    var t = "[A-Za-z]",
      r = "[0-9]",
      s = Ft(r, "[A-Fa-f]"),
      a = Lt(
        Lt("%[EFef]" + s + "%" + s + s + "%" + s + s) +
          "|" +
          Lt("%[89A-Fa-f]" + s + "%" + s + s) +
          "|" +
          Lt("%" + s + s)
      ),
      o = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
      n = Ft("[\\:\\/\\?\\#\\[\\]\\@]", o),
      i = e ? "[\\uE000-\\uF8FF]" : "[]",
      c = Ft(
        t,
        r,
        "[\\-\\.\\_\\~]",
        e
          ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]"
          : "[]"
      );
    Ft(t, r, "[\\+\\-\\.]"), Lt(a + "|" + Ft(c, o, "[\\:]"));
    var d = Lt(
        "(?:25[0-5])|(?:2[0-4][0-9])|(?:1[0-9][0-9])|(?:0?[1-9][0-9])|0?0?" + r
      ),
      h = Lt(d + "\\." + d + "\\." + d + "\\." + d),
      l = Lt(s + "{1,4}"),
      u = Lt(Lt(l + "\\:" + l) + "|" + h),
      p = Lt(Lt(l + "\\:") + "{6}" + u),
      m = Lt("\\:\\:" + Lt(l + "\\:") + "{5}" + u),
      f = Lt(Lt(l) + "?\\:\\:" + Lt(l + "\\:") + "{4}" + u),
      y = Lt(
        Lt(Lt(l + "\\:") + "{0,1}" + l) + "?\\:\\:" + Lt(l + "\\:") + "{3}" + u
      ),
      v = Lt(
        Lt(Lt(l + "\\:") + "{0,2}" + l) + "?\\:\\:" + Lt(l + "\\:") + "{2}" + u
      ),
      e = Lt(Lt(Lt(l + "\\:") + "{0,3}" + l) + "?\\:\\:" + l + "\\:" + u),
      d = Lt(Lt(Lt(l + "\\:") + "{0,4}" + l) + "?\\:\\:" + u),
      u = Lt(Lt(Lt(l + "\\:") + "{0,5}" + l) + "?\\:\\:" + l),
      l = Lt(Lt(Lt(l + "\\:") + "{0,6}" + l) + "?\\:\\:"),
      d = Lt([p, m, f, y, v, e, d, u, l].join("|")),
      u = Lt(Lt(c + "|" + a) + "+");
    Ft(c, o, "[\\:]"), Lt(a + "|" + Ft(c, o));
    l = Lt(a + "|" + Ft(c, o, "[\\:\\@]"));
    return (
      Lt(a + "|" + Ft(c, o, "[\\@]")),
      Lt(l + "|" + Ft("[\\/\\?]", i)),
      {
        NOT_SCHEME: new RegExp(Ft("[^]", t, r, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(Ft("[^\\%\\:]", c, o), "g"),
        NOT_HOST: new RegExp(Ft("[^\\%\\[\\]\\:]", c, o), "g"),
        NOT_PATH: new RegExp(Ft("[^\\%\\/\\:\\@]", c, o), "g"),
        NOT_PATH_NOSCHEME: new RegExp(Ft("[^\\%\\/\\@]", c, o), "g"),
        NOT_QUERY: new RegExp(Ft("[^\\%]", c, o, "[\\:\\@\\/\\?]", i), "g"),
        NOT_FRAGMENT: new RegExp(Ft("[^\\%]", c, o, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(Ft("[^]", c, o), "g"),
        UNRESERVED: new RegExp(c, "g"),
        OTHER_CHARS: new RegExp(Ft("[^\\%]", c, n), "g"),
        PCT_ENCODED: new RegExp(a, "g"),
        IPV4ADDRESS: new RegExp("^(" + h + ")$"),
        IPV6ADDRESS: new RegExp(
          "^\\[?(" +
            d +
            ")" +
            Lt(Lt("\\%25|\\%(?!" + s + "{2})") + "(" + u + ")") +
            "?\\]?$"
        ),
      }
    );
  }
  function Gt(e) {
    throw new RangeError(mt[e]);
  }
  function Ht(e, t) {
    var r = e.split("@"),
      s = "";
    return (
      1 < r.length && ((s = r[0] + "@"), (e = r[1])),
      s +
        (function (e, t) {
          for (var r = [], s = e.length; s--; ) r[s] = t(e[s]);
          return r;
        })((e = e.replace(pt, ".")).split("."), t).join(".")
    );
  }
  function Wt(e) {
    for (var t = [], r = 0, s = e.length; r < s; ) {
      var a,
        o = e.charCodeAt(r++);
      55296 <= o && o <= 56319 && r < s
        ? 56320 == (64512 & (a = e.charCodeAt(r++)))
          ? t.push(((1023 & o) << 10) + (1023 & a) + 65536)
          : (t.push(o), r--)
        : t.push(o);
    }
    return t;
  }
  function Jt(e) {
    e = e.charCodeAt(0);
    return e < 16
      ? "%0" + e.toString(16).toUpperCase()
      : e < 128
      ? "%" + e.toString(16).toUpperCase()
      : e < 2048
      ? "%" +
        ((e >> 6) | 192).toString(16).toUpperCase() +
        "%" +
        ((63 & e) | 128).toString(16).toUpperCase()
      : "%" +
        ((e >> 12) | 224).toString(16).toUpperCase() +
        "%" +
        (((e >> 6) & 63) | 128).toString(16).toUpperCase() +
        "%" +
        ((63 & e) | 128).toString(16).toUpperCase();
  }
  function Bt(e) {
    for (var t = "", r = 0, s = e.length; r < s; ) {
      var a,
        o,
        n = parseInt(e.substr(r + 1, 2), 16);
      n < 128
        ? ((t += String.fromCharCode(n)), (r += 3))
        : 194 <= n && n < 224
        ? (6 <= s - r
            ? ((o = parseInt(e.substr(r + 4, 2), 16)),
              (t += String.fromCharCode(((31 & n) << 6) | (63 & o))))
            : (t += e.substr(r, 6)),
          (r += 6))
        : 224 <= n
        ? (9 <= s - r
            ? ((a = parseInt(e.substr(r + 4, 2), 16)),
              (o = parseInt(e.substr(r + 7, 2), 16)),
              (t += String.fromCharCode(
                ((15 & n) << 12) | ((63 & a) << 6) | (63 & o)
              )))
            : (t += e.substr(r, 9)),
          (r += 9))
        : ((t += e.substr(r, 3)), (r += 3));
    }
    return t;
  }
  function Qt(e, r) {
    function t(e) {
      var t = Bt(e);
      return t.match(r.UNRESERVED) ? t : e;
    }
    return (
      e.scheme &&
        (e.scheme = String(e.scheme)
          .replace(r.PCT_ENCODED, t)
          .toLowerCase()
          .replace(r.NOT_SCHEME, "")),
      void 0 !== e.userinfo &&
        (e.userinfo = String(e.userinfo)
          .replace(r.PCT_ENCODED, t)
          .replace(r.NOT_USERINFO, Jt)
          .replace(r.PCT_ENCODED, Mt)),
      void 0 !== e.host &&
        (e.host = String(e.host)
          .replace(r.PCT_ENCODED, t)
          .toLowerCase()
          .replace(r.NOT_HOST, Jt)
          .replace(r.PCT_ENCODED, Mt)),
      void 0 !== e.path &&
        (e.path = String(e.path)
          .replace(r.PCT_ENCODED, t)
          .replace(e.scheme ? r.NOT_PATH : r.NOT_PATH_NOSCHEME, Jt)
          .replace(r.PCT_ENCODED, Mt)),
      void 0 !== e.query &&
        (e.query = String(e.query)
          .replace(r.PCT_ENCODED, t)
          .replace(r.NOT_QUERY, Jt)
          .replace(r.PCT_ENCODED, Mt)),
      void 0 !== e.fragment &&
        (e.fragment = String(e.fragment)
          .replace(r.PCT_ENCODED, t)
          .replace(r.NOT_FRAGMENT, Jt)
          .replace(r.PCT_ENCODED, Mt)),
      e
    );
  }
  function Zt(e) {
    return e.replace(/^0*(.*)/, "$1") || "0";
  }
  function Yt(e, t) {
    (t = e.match(t.IPV4ADDRESS) || []), (t = dt(t, 2)[1]);
    return t ? t.split(".").map(Zt).join(".") : e;
  }
  function Xt(e, t) {
    var r = e.match(t.IPV6ADDRESS) || [],
      s = dt(r, 3),
      a = s[1],
      r = s[2];
    if (a) {
      for (
        var s = a.toLowerCase().split("::").reverse(),
          a = dt(s, 2),
          s = a[0],
          a = a[1],
          o = a ? a.split(":").map(Zt) : [],
          n = s.split(":").map(Zt),
          a = t.IPV4ADDRESS.test(n[n.length - 1]),
          i = a ? 7 : 8,
          c = n.length - i,
          d = Array(i),
          h = 0;
        h < i;
        ++h
      )
        d[h] = o[h] || n[c + h] || "";
      a && (d[i - 1] = Yt(d[i - 1], t));
      (s = d
        .reduce(function (e, t, r) {
          return (
            (t && "0" !== t) ||
              ((t = e[e.length - 1]) && t.index + t.length === r
                ? t.length++
                : e.push({ index: r, length: 1 })),
            e
          );
        }, [])
        .sort(function (e, t) {
          return t.length - e.length;
        })[0]),
        (a = void 0);
      return (
        (a =
          s && 1 < s.length
            ? ((t = d.slice(0, s.index)),
              (s = d.slice(s.index + s.length)),
              t.join(":") + "::" + s.join(":"))
            : d.join(":")),
        r && (a += "%" + r),
        a
      );
    }
    return e;
  }
  function er(e) {
    var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},
      r = {},
      s = !1 !== t.iri ? ct : it,
      a = (e =
        "suffix" === t.reference
          ? (t.scheme ? t.scheme + ":" : "") + "//" + e
          : e).match(St);
    if (a) {
      kt
        ? ((r.scheme = a[1]),
          (r.userinfo = a[3]),
          (r.host = a[4]),
          (r.port = parseInt(a[5], 10)),
          (r.path = a[6] || ""),
          (r.query = a[7]),
          (r.fragment = a[8]),
          isNaN(r.port) && (r.port = a[5]))
        : ((r.scheme = a[1] || void 0),
          (r.userinfo = -1 !== e.indexOf("@") ? a[3] : void 0),
          (r.host = -1 !== e.indexOf("//") ? a[4] : void 0),
          (r.port = parseInt(a[5], 10)),
          (r.path = a[6] || ""),
          (r.query = -1 !== e.indexOf("?") ? a[7] : void 0),
          (r.fragment = -1 !== e.indexOf("#") ? a[8] : void 0),
          isNaN(r.port) &&
            (r.port = e.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/)
              ? a[4]
              : void 0)),
        r.host && (r.host = Xt(Yt(r.host, s), s)),
        void 0 !== r.scheme ||
        void 0 !== r.userinfo ||
        void 0 !== r.host ||
        void 0 !== r.port ||
        r.path ||
        void 0 !== r.query
          ? void 0 === r.scheme
            ? (r.reference = "relative")
            : void 0 === r.fragment
            ? (r.reference = "absolute")
            : (r.reference = "uri")
          : (r.reference = "same-document"),
        t.reference &&
          "suffix" !== t.reference &&
          t.reference !== r.reference &&
          (r.error = r.error || "URI is not a " + t.reference + " reference.");
      a = Et[(t.scheme || r.scheme || "").toLowerCase()];
      if (t.unicodeSupport || (a && a.unicodeSupport)) Qt(r, s);
      else {
        if (r.host && (t.domainHost || (a && a.domainHost)))
          try {
            r.host = bt.toASCII(
              r.host.replace(s.PCT_ENCODED, Bt).toLowerCase()
            );
          } catch (e) {
            r.error =
              r.error ||
              "Host's domain name can not be converted to ASCII via punycode: " +
                e;
          }
        Qt(r, it);
      }
      a && a.parse && a.parse(r, t);
    } else r.error = r.error || "URI can not be parsed.";
    return r;
  }
  function tr(e) {
    for (var t = []; e.length; )
      if (e.match(_t)) e = e.replace(_t, "");
      else if (e.match(Pt)) e = e.replace(Pt, "/");
      else if (e.match(jt)) (e = e.replace(jt, "/")), t.pop();
      else if ("." === e || ".." === e) e = "";
      else {
        var r = e.match(Nt);
        if (!r) throw new Error("Unexpected dot segment condition");
        r = r[0];
        (e = e.slice(r.length)), t.push(r);
      }
    return t.join("");
  }
  function rr(t) {
    var r = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},
      e = r.iri ? ct : it,
      s = [],
      a = Et[(r.scheme || t.scheme || "").toLowerCase()];
    if (
      (a && a.serialize && a.serialize(t, r),
      t.host &&
        !e.IPV6ADDRESS.test(t.host) &&
        (r.domainHost || (a && a.domainHost)))
    )
      try {
        t.host = r.iri
          ? bt.toUnicode(t.host)
          : bt.toASCII(t.host.replace(e.PCT_ENCODED, Bt).toLowerCase());
      } catch (e) {
        t.error =
          t.error ||
          "Host's domain name can not be converted to " +
            (r.iri ? "Unicode" : "ASCII") +
            " via punycode: " +
            e;
      }
    Qt(t, e),
      "suffix" !== r.reference && t.scheme && (s.push(t.scheme), s.push(":"));
    var o,
      n,
      o =
        ((o = t),
        (e = !1 !== (n = r).iri ? ct : it),
        (n = []),
        void 0 !== o.userinfo && (n.push(o.userinfo), n.push("@")),
        void 0 !== o.host &&
          n.push(
            Xt(Yt(String(o.host), e), e).replace(
              e.IPV6ADDRESS,
              function (e, t, r) {
                return "[" + t + (r ? "%25" + r : "") + "]";
              }
            )
          ),
        ("number" != typeof o.port && "string" != typeof o.port) ||
          (n.push(":"), n.push(String(o.port))),
        n.length ? n.join("") : void 0);
    return (
      void 0 !== o &&
        ("suffix" !== r.reference && s.push("//"),
        s.push(o),
        t.path && "/" !== t.path.charAt(0) && s.push("/")),
      void 0 !== t.path &&
        ((n = t.path),
        r.absolutePath || (a && a.absolutePath) || (n = tr(n)),
        void 0 === o && (n = n.replace(/^\/\//, "/%2F")),
        s.push(n)),
      void 0 !== t.query && (s.push("?"), s.push(t.query)),
      void 0 !== t.fragment && (s.push("#"), s.push(t.fragment)),
      s.join("")
    );
  }
  function sr(e, t) {
    var r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {},
      s = {};
    return (
      arguments[3] || ((e = er(rr(e, r), r)), (t = er(rr(t, r), r))),
      !(r = r || {}).tolerant && t.scheme
        ? ((s.scheme = t.scheme),
          (s.userinfo = t.userinfo),
          (s.host = t.host),
          (s.port = t.port),
          (s.path = tr(t.path || "")),
          (s.query = t.query))
        : (void 0 !== t.userinfo || void 0 !== t.host || void 0 !== t.port
            ? ((s.userinfo = t.userinfo),
              (s.host = t.host),
              (s.port = t.port),
              (s.path = tr(t.path || "")),
              (s.query = t.query))
            : (t.path
                ? ("/" === t.path.charAt(0)
                    ? (s.path = tr(t.path))
                    : ((void 0 === e.userinfo &&
                        void 0 === e.host &&
                        void 0 === e.port) ||
                      e.path
                        ? e.path
                          ? (s.path =
                              e.path.slice(0, e.path.lastIndexOf("/") + 1) +
                              t.path)
                          : (s.path = t.path)
                        : (s.path = "/" + t.path),
                      (s.path = tr(s.path))),
                  (s.query = t.query))
                : ((s.path = e.path),
                  void 0 !== t.query
                    ? (s.query = t.query)
                    : (s.query = e.query)),
              (s.userinfo = e.userinfo),
              (s.host = e.host),
              (s.port = e.port)),
          (s.scheme = e.scheme)),
      (s.fragment = t.fragment),
      s
    );
  }
  function ar(e, t) {
    return e && e.toString().replace((t && t.iri ? ct : it).PCT_ENCODED, Bt);
  }
  function or(e) {
    return "boolean" == typeof e.secure
      ? e.secure
      : "wss" === String(e.scheme).toLowerCase();
  }
  function nr(e) {
    var t = Bt(e);
    return t.match(Ct) ? t : e;
  }
  (is = Vt.exports),
    (hs = is),
    (it = Kt(!1)),
    (ct = Kt(!0)),
    (dt = function (e, t) {
      if (Array.isArray(e)) return e;
      if (Symbol.iterator in Object(e))
        return (function (e, t) {
          var r = [],
            s = !0,
            a = !1,
            o = void 0;
          try {
            for (
              var n, i = e[Symbol.iterator]();
              !(s = (n = i.next()).done) &&
              (r.push(n.value), !t || r.length !== t);
              s = !0
            );
          } catch (e) {
            (a = !0), (o = e);
          } finally {
            try {
              !s && i.return && i.return();
            } finally {
              if (a) throw o;
            }
          }
          return r;
        })(e, t);
      throw new TypeError(
        "Invalid attempt to destructure non-iterable instance"
      );
    }),
    (ht = 2147483647),
    (lt = /^xn--/),
    (ut = /[^\0-\x7E]/),
    (pt = /[\x2E\u3002\uFF0E\uFF61]/g),
    (mt = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input",
    }),
    (ft = Math.floor),
    (yt = String.fromCharCode),
    (vt = function (e, t) {
      return e + 22 + 75 * (e < 26) - ((0 != t) << 5);
    }),
    ($t = function (e, t, r) {
      var s = 0;
      for (e = r ? ft(e / 700) : e >> 1, e += ft(e / t); 455 < e; s += 36)
        e = ft(e / 35);
      return ft(s + (36 * e) / (e + 38));
    }),
    (wt = function (e) {
      var t = [],
        r = (e = Wt(e)).length,
        s = 128,
        a = 0,
        o = 72,
        n = !0,
        i = !1,
        c = void 0;
      try {
        for (
          var d, h = e[Symbol.iterator]();
          !(n = (d = h.next()).done);
          n = !0
        ) {
          var l = d.value;
          l < 128 && t.push(yt(l));
        }
      } catch (e) {
        (i = !0), (c = e);
      } finally {
        try {
          !n && h.return && h.return();
        } finally {
          if (i) throw c;
        }
      }
      var u = t.length,
        p = u;
      for (u && t.push("-"); p < r; ) {
        var m = ht,
          f = !0,
          y = !1,
          v = void 0;
        try {
          for (
            var $, g = e[Symbol.iterator]();
            !(f = ($ = g.next()).done);
            f = !0
          ) {
            var w = $.value;
            s <= w && w < m && (m = w);
          }
        } catch (e) {
          (y = !0), (v = e);
        } finally {
          try {
            !f && g.return && g.return();
          } finally {
            if (y) throw v;
          }
        }
        var b = p + 1;
        m - s > ft((ht - a) / b) && Gt("overflow"), (a += (m - s) * b);
        var s = m,
          E = !0,
          y = !1,
          v = void 0;
        try {
          for (
            var S, k = e[Symbol.iterator]();
            !(E = (S = k.next()).done);
            E = !0
          ) {
            var _ = S.value;
            if ((_ < s && ++a > ht && Gt("overflow"), _ == s)) {
              for (var P = a, j = 36; ; j += 36) {
                var N = j <= o ? 1 : o + 26 <= j ? 26 : j - o;
                if (P < N) break;
                var x = P - N,
                  C = 36 - N;
                t.push(yt(vt(N + (x % C), 0))), (P = ft(x / C));
              }
              t.push(yt(vt(P, 0))), (o = $t(a, b, p == u)), (a = 0), ++p;
            }
          }
        } catch (e) {
          (y = !0), (v = e);
        } finally {
          try {
            !E && k.return && k.return();
          } finally {
            if (y) throw v;
          }
        }
        ++a, ++s;
      }
      return t.join("");
    }),
    (bt = {
      version: "2.1.0",
      ucs2: {
        decode: Wt,
        encode: function (e) {
          return String.fromCodePoint.apply(
            String,
            (function (e) {
              if (Array.isArray(e)) {
                for (var t = 0, r = Array(e.length); t < e.length; t++)
                  r[t] = e[t];
                return r;
              }
              return Array.from(e);
            })(e)
          );
        },
      },
      decode: (gt = function (e) {
        var t = [],
          r = e.length,
          s = 0,
          a = 128,
          o = 72,
          n = e.lastIndexOf("-");
        n < 0 && (n = 0);
        for (var i = 0; i < n; ++i)
          128 <= e.charCodeAt(i) && Gt("not-basic"), t.push(e.charCodeAt(i));
        for (var c = 0 < n ? n + 1 : 0; c < r; ) {
          for (var d = s, h = 1, l = 36; ; l += 36) {
            r <= c && Gt("invalid-input");
            var u =
              (p = e.charCodeAt(c++)) - 48 < 10
                ? p - 22
                : p - 65 < 26
                ? p - 65
                : p - 97 < 26
                ? p - 97
                : 36;
            (36 <= u || u > ft((ht - s) / h)) && Gt("overflow"), (s += u * h);
            var p = l <= o ? 1 : o + 26 <= l ? 26 : l - o;
            if (u < p) break;
            p = 36 - p;
            h > ft(ht / p) && Gt("overflow"), (h *= p);
          }
          var m = t.length + 1,
            o = $t(s - d, m, 0 == d);
          ft(s / m) > ht - a && Gt("overflow"),
            (a += ft(s / m)),
            (s %= m),
            t.splice(s++, 0, a);
        }
        return String.fromCodePoint.apply(String, t);
      }),
      encode: wt,
      toASCII: function (e) {
        return Ht(e, function (e) {
          return ut.test(e) ? "xn--" + wt(e) : e;
        });
      },
      toUnicode: function (e) {
        return Ht(e, function (e) {
          return lt.test(e) ? gt(e.slice(4).toLowerCase()) : e;
        });
      },
    }),
    (Et = {}),
    (St =
      /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i),
    (kt = void 0 === "".match(/(){0}/)[1]),
    (_t = /^\.\.?\//),
    (Pt = /^\/\.(\/|$)/),
    (jt = /^\/\.\.(\/|$)/),
    (Nt = /^\/?(?:.|\n)*?(?=\/|$)/),
    (Mr = {
      scheme: "https",
      domainHost: (Ur = {
        scheme: "http",
        domainHost: !0,
        parse: function (e, t) {
          return (
            e.host || (e.error = e.error || "HTTP URIs must have a host."), e
          );
        },
        serialize: function (e, t) {
          var r = "https" === String(e.scheme).toLowerCase();
          return (
            (e.port !== (r ? 443 : 80) && "" !== e.port) || (e.port = void 0),
            e.path || (e.path = "/"),
            e
          );
        },
      }).domainHost,
      parse: Ur.parse,
      serialize: Ur.serialize,
    }),
    (ns = {
      scheme: "wss",
      domainHost: (Kr = {
        scheme: "ws",
        domainHost: !0,
        parse: function (e, t) {
          return (
            (e.secure = or(e)),
            (e.resourceName = (e.path || "/") + (e.query ? "?" + e.query : "")),
            (e.path = void 0),
            (e.query = void 0),
            e
          );
        },
        serialize: function (e, t) {
          var r, s;
          return (
            (e.port !== (or(e) ? 443 : 80) && "" !== e.port) ||
              (e.port = void 0),
            "boolean" == typeof e.secure &&
              ((e.scheme = e.secure ? "wss" : "ws"), (e.secure = void 0)),
            e.resourceName &&
              ((r = e.resourceName.split("?")),
              (r = (s = dt(r, 2))[0]),
              (s = s[1]),
              (e.path = r && "/" !== r ? r : void 0),
              (e.query = s),
              (e.resourceName = void 0)),
            (e.fragment = void 0),
            e
          );
        },
      }).domainHost,
      parse: Kr.parse,
      serialize: Kr.serialize,
    }),
    (xt = {}),
    (ds =
      "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]"),
    (is = Lt(
      Lt("%[EFef]" + (at = "[0-9A-Fa-f]") + "%" + at + at + "%" + at + at) +
        "|" +
        Lt("%[89A-Fa-f]" + at + "%" + at + at) +
        "|" +
        Lt("%" + at + at)
    )),
    (at = Ft(
      "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]",
      '[\\"\\\\]'
    )),
    (Ct = new RegExp(ds, "g")),
    (At = new RegExp(is, "g")),
    (It = new RegExp(
      Ft(
        "[^]",
        "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]",
        "[\\.]",
        '[\\"]',
        at
      ),
      "g"
    )),
    (Tt = new RegExp(
      Ft("[^]", ds, "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]"),
      "g"
    )),
    (Rt = Tt),
    (is = {
      scheme: "mailto",
      parse: function (e, t) {
        var r = e,
          s = (r.to = r.path ? r.path.split(",") : []);
        if (((r.path = void 0), r.query)) {
          for (
            var a = !1, o = {}, n = r.query.split("&"), i = 0, c = n.length;
            i < c;
            ++i
          ) {
            var d = n[i].split("=");
            switch (d[0]) {
              case "to":
                for (var h = d[1].split(","), l = 0, u = h.length; l < u; ++l)
                  s.push(h[l]);
                break;
              case "subject":
                r.subject = ar(d[1], t);
                break;
              case "body":
                r.body = ar(d[1], t);
                break;
              default:
                (a = !0), (o[ar(d[0], t)] = ar(d[1], t));
            }
          }
          a && (r.headers = o);
        }
        r.query = void 0;
        for (var p = 0, m = s.length; p < m; ++p) {
          var f = s[p].split("@");
          if (((f[0] = ar(f[0])), t.unicodeSupport))
            f[1] = ar(f[1], t).toLowerCase();
          else
            try {
              f[1] = bt.toASCII(ar(f[1], t).toLowerCase());
            } catch (e) {
              r.error =
                r.error ||
                "Email address's domain name can not be converted to ASCII via punycode: " +
                  e;
            }
          s[p] = f.join("@");
        }
        return r;
      },
      serialize: function (e, t) {
        var r,
          s = e,
          a =
            null != (r = e.to)
              ? r instanceof Array
                ? r
                : "number" != typeof r.length ||
                  r.split ||
                  r.setInterval ||
                  r.call
                ? [r]
                : Array.prototype.slice.call(r)
              : [];
        if (a) {
          for (var o = 0, n = a.length; o < n; ++o) {
            var i = String(a[o]),
              c = i.lastIndexOf("@"),
              d = i.slice(0, c).replace(At, nr).replace(At, Mt).replace(It, Jt),
              c = i.slice(c + 1);
            try {
              c = t.iri ? bt.toUnicode(c) : bt.toASCII(ar(c, t).toLowerCase());
            } catch (e) {
              s.error =
                s.error ||
                "Email address's domain name can not be converted to " +
                  (t.iri ? "Unicode" : "ASCII") +
                  " via punycode: " +
                  e;
            }
            a[o] = d + "@" + c;
          }
          s.path = a.join(",");
        }
        var h = (e.headers = e.headers || {});
        e.subject && (h.subject = e.subject), e.body && (h.body = e.body);
        var l,
          u = [];
        for (l in h)
          h[l] !== xt[l] &&
            u.push(
              l.replace(At, nr).replace(At, Mt).replace(Tt, Jt) +
                "=" +
                h[l].replace(At, nr).replace(At, Mt).replace(Rt, Jt)
            );
        return u.length && (s.query = u.join("&")), s;
      },
    }),
    (Ot = /^([^\:]+)\:(.*)/),
    (at = {
      scheme: "urn",
      parse: function (e, t) {
        var r,
          s = e.path && e.path.match(Ot),
          a = e;
        return (
          s
            ? ((r = t.scheme || a.scheme || "urn"),
              (e = s[1].toLowerCase()),
              (s = s[2]),
              (r = r + ":" + (t.nid || e)),
              (r = Et[r]),
              (a.nid = e),
              (a.nss = s),
              (a.path = void 0),
              r && (a = r.parse(a, t)))
            : (a.error = a.error || "URN can not be parsed."),
          a
        );
      },
      serialize: function (e, t) {
        var r = t.scheme || e.scheme || "urn",
          s = e.nid,
          r = r + ":" + (t.nid || s),
          r = Et[r],
          r = (e = r ? r.serialize(e, t) : e),
          e = e.nss;
        return (r.path = (s || t.nid) + ":" + e), r;
      },
    }),
    (Dt = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/),
    (ds = {
      scheme: "urn:uuid",
      parse: function (e, t) {
        return (
          (e.uuid = e.nss),
          (e.nss = void 0),
          t.tolerant ||
            (e.uuid && e.uuid.match(Dt)) ||
            (e.error = e.error || "UUID is not valid."),
          e
        );
      },
      serialize: function (e, t) {
        var r = e;
        return (r.nss = (e.uuid || "").toLowerCase()), r;
      },
    }),
    (Et[Ur.scheme] = Ur),
    (Et[Mr.scheme] = Mr),
    (Et[Kr.scheme] = Kr),
    (Et[ns.scheme] = ns),
    (Et[is.scheme] = is),
    (Et[at.scheme] = at),
    (Et[ds.scheme] = ds),
    (hs.SCHEMES = Et),
    (hs.pctEncChar = Jt),
    (hs.pctDecChars = Bt),
    (hs.parse = er),
    (hs.removeDotSegments = tr),
    (hs.serialize = rr),
    (hs.resolveComponents = sr),
    (hs.resolve = function (e, t, r) {
      r = (function (e, t) {
        var r = e;
        if (t) for (var s in t) r[s] = t[s];
        return r;
      })({ scheme: "null" }, r);
      return rr(sr(er(e, r), er(t, r), r, !0), r);
    }),
    (hs.normalize = function (e, t) {
      "string" == typeof e
        ? (e = rr(er(e, t), t))
        : "object" === Ut(e) && (e = er(rr(e, t), t));
      return e;
    }),
    (hs.equal = function (e, t, r) {
      "string" == typeof e
        ? (e = rr(er(e, r), r))
        : "object" === Ut(e) && (e = rr(e, r));
      "string" == typeof t
        ? (t = rr(er(t, r), r))
        : "object" === Ut(t) && (t = rr(t, r));
      return e === t;
    }),
    (hs.escapeComponent = function (e, t) {
      return e && e.toString().replace((t && t.iri ? ct : it).ESCAPE, Jt);
    }),
    (hs.unescapeComponent = ar),
    Object.defineProperty(hs, "__esModule", { value: !0 });
  const ir = new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const",
  ]);
  function cr(e, t = !0) {
    return (
      "boolean" == typeof e ||
      (!0 === t
        ? !hr(e)
        : t &&
          (function t(e) {
            let r = 0;
            for (const s in e) {
              if ("$ref" === s) return 1 / 0;
              if (
                (r++,
                !ir.has(s) &&
                  ("object" == typeof e[s] && de(e[s], (e) => (r += t(e))),
                  r === 1 / 0))
              )
                return 1 / 0;
            }
            return r;
          })(e) <= t)
    );
  }
  const dr = new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor",
  ]);
  function hr(e) {
    for (const t in e) {
      if (dr.has(t)) return !0;
      const r = e[t];
      if (Array.isArray(r) && r.some(hr)) return !0;
      if ("object" == typeof r && hr(r)) return !0;
    }
    return !1;
  }
  function lr(e = "", t) {
    return !1 !== t && (e = mr(e)), ur(Vt.exports.parse(e));
  }
  function ur(e) {
    return Vt.exports.serialize(e).split("#")[0] + "#";
  }
  const pr = /#\/?$/;
  function mr(e) {
    return e ? e.replace(pr, "") : "";
  }
  function fr(e, t) {
    return (t = mr(t)), Vt.exports.resolve(e, t);
  }
  const yr = /^[a-z_][-a-z0-9._]*$/i;
  function vr(e) {
    Er(e) && (Sr(e), br(e))
      ? (function (e) {
          const { schema: t, opts: r, gen: s } = e;
          $r(e, () => {
            r.$comment && t.$comment && _r(e),
              (function (e) {
                var { schema: t, opts: r } = e;
                void 0 !== t.default &&
                  r.useDefaults &&
                  r.strictSchema &&
                  ve(e, "default is ignored in the schema root");
              })(e),
              s.let($e.vErrors, null),
              s.let($e.errors, 0),
              r.unevaluated &&
                (function (e) {
                  const { gen: t, validateName: r } = e;
                  (e.evaluated = t.const("evaluated", v`${r}.evaluated`)),
                    t.if(v`${e.evaluated}.dynamicProps`, () =>
                      t.assign(v`${e.evaluated}.props`, v`undefined`)
                    ),
                    t.if(v`${e.evaluated}.dynamicItems`, () =>
                      t.assign(v`${e.evaluated}.items`, v`undefined`)
                    );
                })(e),
              kr(e),
              (function (e) {
                const {
                  gen: t,
                  schemaEnv: r,
                  validateName: s,
                  ValidationError: a,
                  opts: o,
                } = e;
                r.$async
                  ? t.if(
                      v`${$e.errors} === 0`,
                      () => t.return($e.data),
                      () => t.throw(v`new ${a}(${$e.vErrors})`)
                    )
                  : (t.assign(v`${s}.errors`, $e.vErrors),
                    o.unevaluated &&
                      (function ({ gen: e, evaluated: t, props: r, items: s }) {
                        r instanceof p && e.assign(v`${t}.props`, r);
                        s instanceof p && e.assign(v`${t}.items`, s);
                      })(e),
                    t.return(v`${$e.errors} === 0`));
              })(e);
          });
        })(e)
      : $r(e, () =>
          (function (e) {
            const { gen: t, schema: r, validateName: s } = e;
            !1 === r
              ? je(e, !1)
              : "object" == typeof r && !0 === r.$async
              ? t.return($e.data)
              : (t.assign(v`${s}.errors`, null), t.return(!0));
          })(e)
        );
  }
  function $r(
    { gen: r, validateName: e, schema: s, schemaEnv: t, opts: a },
    o
  ) {
    a.code.es5
      ? r.func(e, v`${$e.data}, ${$e.valCxt}`, t.$async, () => {
          var e, t;
          r.code(v`"use strict"; ${gr(s, a)}`),
            (t = a),
            (e = r).if(
              $e.valCxt,
              () => {
                e.var($e.instancePath, v`${$e.valCxt}.${$e.instancePath}`),
                  e.var($e.parentData, v`${$e.valCxt}.${$e.parentData}`),
                  e.var(
                    $e.parentDataProperty,
                    v`${$e.valCxt}.${$e.parentDataProperty}`
                  ),
                  e.var($e.rootData, v`${$e.valCxt}.${$e.rootData}`),
                  t.dynamicRef &&
                    e.var(
                      $e.dynamicAnchors,
                      v`${$e.valCxt}.${$e.dynamicAnchors}`
                    );
              },
              () => {
                e.var($e.instancePath, v`""`),
                  e.var($e.parentData, v`undefined`),
                  e.var($e.parentDataProperty, v`undefined`),
                  e.var($e.rootData, $e.data),
                  t.dynamicRef && e.var($e.dynamicAnchors, v`{}`);
              }
            ),
            r.code(o);
        })
      : r.func(
          e,
          v`${$e.data}, ${
            ((e = a),
            v`{${$e.instancePath}="", ${$e.parentData}, ${
              $e.parentDataProperty
            }, ${$e.rootData}=${$e.data}${
              e.dynamicRef ? v`, ${$e.dynamicAnchors}={}` : y
            }}={}`)
          }`,
          t.$async,
          () => r.code(gr(s, a)).code(o)
        );
  }
  function gr(e, t) {
    e = "object" == typeof e && e[t.schemaId];
    return e && (t.code.source || t.code.process)
      ? v`/*# sourceURL=${e} */`
      : y;
  }
  function wr(e, t) {
    (Er(e) && (Sr(e), br(e))
      ? function (e, t) {
          const { schema: r, gen: s, opts: a } = e;
          a.$comment && r.$comment && _r(e);
          (function (e) {
            var t = e.schema[e.opts.schemaId];
            t && (e.baseId = fr(e.baseId, t));
          })(e),
            (function (e) {
              if (e.schema.$async && !e.schemaEnv.$async)
                throw new Error("async schema in sync schema");
            })(e);
          var o = s.const("_errs", $e.errors);
          kr(e, o), s.var(t, v`${o} === ${$e.errors}`);
        }
      : function (e, t) {
          const { gen: r, schema: s } = e;
          !1 === s ? (r.var(t, !1), je(e)) : r.var(t, !0);
        })(e, t);
  }
  function br({ schema: e, self: t }) {
    if ("boolean" == typeof e) return !e;
    for (const r in e) if (t.RULES.all[r]) return 1;
  }
  function Er(e) {
    return "boolean" != typeof e.schema;
  }
  function Sr(e) {
    ae(e),
      (function (e) {
        const { schema: t, errSchemaPath: r, opts: s, self: a } = e;
        t.$ref &&
          s.ignoreKeywordsWithRef &&
          oe(t, a.RULES) &&
          a.logger.warn(`$ref: keywords ignored in schema at path "${r}"`);
      })(e);
  }
  function kr(e, t) {
    if (e.opts.jtd) return Pr(e, [], !1, t), 0;
    var r = Te(e.schema);
    Pr(e, r, !Oe(e, r), t);
  }
  function _r({ gen: e, schemaEnv: t, schema: r, errSchemaPath: s, opts: a }) {
    r = r.$comment;
    !0 === a.$comment
      ? e.code(v`${$e.self}.logger.log(${r})`)
      : "function" == typeof a.$comment &&
        ((s = f`${s}/$comment`),
        (t = e.scopeValue("root", { ref: t.root })),
        e.code(v`${$e.self}.opts.$comment(${r}, ${s}, ${t}.schema)`));
  }
  function Pr(t, r, s, a) {
    const { gen: o, schema: n, data: i, allErrors: c, opts: d, self: e } = t,
      { RULES: h } = e;
    var l, u;
    function p(e) {
      Ae(n, e) &&
        (e.type
          ? (o.if(qe(e.type, i, d.strictNumbers)),
            jr(t, e),
            1 === r.length && r[0] === e.type && s && (o.else(), Fe(t)),
            o.endIf())
          : jr(t, e),
        c || o.if(v`${$e.errors} === ${a || 0}`));
    }
    !n.$ref || (!d.ignoreKeywordsWithRef && oe(n, h))
      ? (d.jtd ||
          ((u = r),
          !(l = t).schemaEnv.meta &&
            l.opts.strictTypes &&
            ((function (t, r) {
              r.length &&
                (t.dataTypes.length
                  ? (r.forEach((e) => {
                      Nr(t.dataTypes, e) ||
                        xr(
                          t,
                          `type "${e}" not allowed by context "${t.dataTypes.join(
                            ","
                          )}"`
                        );
                    }),
                    (t.dataTypes = t.dataTypes.filter((e) => Nr(r, e))))
                  : (t.dataTypes = r));
            })(l, u),
            l.opts.allowUnionTypes ||
              (function (e, t) {
                1 < t.length &&
                  (2 !== t.length || !t.includes("null")) &&
                  xr(e, "use allowUnionTypes to allow union type keyword");
              })(l, u),
            (function (e, t) {
              var r = e.self.RULES.all;
              for (const a in r) {
                var s = r[a];
                if ("object" == typeof s && Ie(e.schema, s)) {
                  const { type: o } = s.definition;
                  o.length &&
                    !o.some((e) =>
                      (function (e, t) {
                        return (
                          e.includes(t) ||
                          ("number" === t && e.includes("integer"))
                        );
                      })(t, e)
                    ) &&
                    xr(e, `missing type "${o.join(",")}" for keyword "${a}"`);
                }
              }
            })(l, l.dataTypes))),
        o.block(() => {
          for (const e of h.rules) p(e);
          p(h.post);
        }))
      : o.block(() => Ar(t, "$ref", h.all.$ref.definition));
  }
  function jr(t, r) {
    const {
      gen: e,
      schema: s,
      opts: { useDefaults: a },
    } = t;
    a &&
      (function (r, e) {
        const { properties: t, items: s } = r.schema;
        if ("object" === e && t) for (const a in t) Le(r, a, t[a].default);
        else
          "array" === e &&
            Array.isArray(s) &&
            s.forEach((e, t) => Le(r, t, e.default));
      })(t, r.type),
      e.block(() => {
        for (const e of r.rules)
          Ie(s, e) && Ar(t, e.keyword, e.definition, r.type);
      });
  }
  function Nr(e, t) {
    return e.includes(t) || ("integer" === t && e.includes("number"));
  }
  function xr(e, t) {
    ve(
      e,
      (t += ` at "${e.schemaEnv.baseId + e.errSchemaPath}" (strictTypes)`),
      e.opts.strictTypes
    );
  }
  class Cr {
    constructor(e, t, r) {
      if (
        (!(function ({ schema: t, opts: e, self: r, errSchemaPath: s }, a, o) {
          if (
            Array.isArray(a.keyword) ? !a.keyword.includes(o) : a.keyword !== o
          )
            throw new Error("ajv implementation error");
          const n = a.dependencies;
          if (
            null !== n &&
            void 0 !== n &&
            n.some((e) => !Object.prototype.hasOwnProperty.call(t, e))
          )
            throw new Error(
              `parent schema must have dependencies of ${o}: ${n.join(",")}`
            );
          if (a.validateSchema && !a.validateSchema(t[o])) {
            a =
              `keyword "${o}" value is invalid at path "${s}": ` +
              r.errorsText(a.validateSchema.errors);
            if ("log" !== e.validateSchema) throw new Error(a);
            r.logger.error(a);
          }
        })(e, t, r),
        (this.gen = e.gen),
        (this.allErrors = e.allErrors),
        (this.keyword = r),
        (this.data = e.data),
        (this.schema = e.schema[r]),
        (this.$data =
          t.$data && e.opts.$data && this.schema && this.schema.$data),
        (this.schemaValue = ne(e, this.schema, r, this.$data)),
        (this.schemaType = t.schemaType),
        (this.parentSchema = e.schema),
        (this.params = {}),
        (this.it = e),
        (this.def = t),
        this.$data)
      )
        this.schemaCode = e.gen.const(
          "vSchema",
          (function (e, { dataLevel: r, dataNames: t, dataPathArr: s }) {
            let a, o;
            if ("" === e) return $e.rootData;
            if ("/" === e[0]) {
              if (!Ir.test(e)) throw new Error(`Invalid JSON-pointer: ${e}`);
              (a = e), (o = $e.rootData);
            } else {
              var n = Tr.exec(e);
              if (!n) throw new Error(`Invalid JSON-pointer: ${e}`);
              var i = +n[1];
              if (((a = n[2]), "#" === a)) {
                if (r <= i) throw new Error(d("property/index", i));
                return s[r - i];
              }
              if (r < i) throw new Error(d("data", i));
              if (((o = t[r - i]), !a)) return o;
            }
            let c = o;
            i = a.split("/");
            for (const h of i)
              h && ((o = v`${o}${w(ce(h))}`), (c = v`${c} && ${o}`));
            return c;
            function d(e, t) {
              return `Cannot access ${e} ${t} levels up, current level is ${r}`;
            }
          })(this.$data, e)
        );
      else if (
        ((this.schemaCode = this.schemaValue),
        ([s, a, o = !1] = [this.schema, t.schemaType, t.allowUndefined]),
        a.length &&
          !a.some((e) =>
            "array" === e
              ? Array.isArray(s)
              : "object" === e
              ? s && "object" == typeof s && !Array.isArray(s)
              : typeof s == e || (o && void 0 === s)
          ))
      )
        throw new Error(`${r} value must be ${JSON.stringify(t.schemaType)}`);
      var s, a, o;
      ("code" in t ? t.trackErrors : !1 !== t.errors) &&
        (this.errsCount = e.gen.const("_errs", $e.errors));
    }
    result(e, t, r) {
      this.failResult(B(e), t, r);
    }
    failResult(e, t, r) {
      this.gen.if(e),
        r ? r() : this.error(),
        t
          ? (this.gen.else(), t(), this.allErrors && this.gen.endIf())
          : this.allErrors
          ? this.gen.endIf()
          : this.gen.else();
    }
    pass(e, t) {
      this.failResult(B(e), void 0, t);
    }
    fail(e) {
      if (void 0 === e)
        return this.error(), void (this.allErrors || this.gen.if(!1));
      this.gen.if(e),
        this.error(),
        this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    fail$data(e) {
      if (!this.$data) return this.fail(e);
      var { schemaCode: t } = this;
      this.fail(v`${t} !== undefined && (${X(this.invalid$data(), e)})`);
    }
    error(e, t, r) {
      if (t)
        return this.setParams(t), this._error(e, r), void this.setParams({});
      this._error(e, r);
    }
    _error(e, t) {
      (e
        ? function (e, t = ge, r) {
            var { it: s } = e,
              { gen: a, compositeRule: o, allErrors: n } = s;
            Ee(a, _e(e, t, r)), o || n || Se(s, $e.vErrors);
          }
        : be)(this, this.def.error, t);
    }
    $dataError() {
      be(this, this.def.$dataError || we);
    }
    reset() {
      if (void 0 === this.errsCount)
        throw new Error('add "trackErrors" to keyword definition');
      var e, t;
      (e = this.gen),
        (t = this.errsCount),
        e.assign($e.errors, t),
        e.if(v`${$e.vErrors} !== null`, () =>
          e.if(
            t,
            () => e.assign(v`${$e.vErrors}.length`, t),
            () => e.assign($e.vErrors, null)
          )
        );
    }
    ok(e) {
      this.allErrors || this.gen.if(e);
    }
    setParams(e, t) {
      t ? Object.assign(this.params, e) : (this.params = e);
    }
    block$data(e, t, r = y) {
      this.gen.block(() => {
        this.check$data(e, r), t();
      });
    }
    check$data(e = y, t = y) {
      if (this.$data) {
        const { gen: r, schemaCode: s, schemaType: a, def: o } = this;
        r.if(X(v`${s} === undefined`, t)),
          e !== y && r.assign(e, !0),
          (a.length || o.validateSchema) &&
            (r.elseIf(this.invalid$data()),
            this.$dataError(),
            e !== y && r.assign(e, !1)),
          r.else();
      }
    }
    invalid$data() {
      const { gen: e, schemaCode: t, schemaType: r, def: s, it: a } = this;
      return X(
        (function () {
          if (r.length) {
            if (!(t instanceof p)) throw new Error("ajv implementation error");
            return v`${ze(
              Array.isArray(r) ? r : [r],
              t,
              a.opts.strictNumbers,
              Ne.Wrong
            )}`;
          }
          return y;
        })(),
        (function () {
          if (s.validateSchema)
            return v`!${e.scopeValue("validate$data", {
              ref: s.validateSchema,
            })}(${t})`;
          return y;
        })()
      );
    }
    subschema(e, t) {
      var r,
        s,
        a,
        o,
        n,
        i = tt(this.it, e);
      !(function (
        t,
        r,
        { dataProp: e, dataPropType: s, data: a, dataTypes: o, propertyName: n }
      ) {
        if (void 0 !== a && void 0 !== e)
          throw new Error(
            'both "data" and "dataProp" passed, only one allowed'
          );
        const { gen: i } = r;
        var c, d, h;
        function l(e) {
          (t.data = e),
            (t.dataLevel = r.dataLevel + 1),
            (t.dataTypes = []),
            (r.definedProperties = new Set()),
            (t.parentData = r.data),
            (t.dataNames = [...r.dataNames, e]);
        }
        void 0 !== e &&
          (({ errorPath: c, dataPathArr: d, opts: h } = r),
          l(i.let("data", v`${r.data}${w(e)}`, !0)),
          (t.errorPath = f`${c}${ye(e, s, h.jsPropertySyntax)}`),
          (t.parentDataProperty = v`${e}`),
          (t.dataPathArr = [...d, t.parentDataProperty])),
          void 0 !== a &&
            (l(a instanceof p ? a : i.let("data", a, !0)),
            void 0 !== n && (t.propertyName = n)),
          o && (t.dataTypes = o);
      })(i, this.it, e),
        ([
          r,
          {
            jtdDiscriminator: s,
            jtdMetadata: a,
            compositeRule: o,
            createErrors: n,
            allErrors: e,
          },
        ] = [i, e]),
        void 0 !== o && (r.compositeRule = o),
        void 0 !== n && (r.createErrors = n),
        void 0 !== e && (r.allErrors = e),
        (r.jtdDiscriminator = s),
        (r.jtdMetadata = a);
      i = { ...this.it, ...i, items: void 0, props: void 0 };
      return wr(i, t), i;
    }
    mergeEvaluated(e, t) {
      const { it: r, gen: s } = this;
      r.opts.unevaluated &&
        (!0 !== r.props &&
          void 0 !== e.props &&
          (r.props = le.props(s, e.props, r.props, t)),
        !0 !== r.items &&
          void 0 !== e.items &&
          (r.items = le.items(s, e.items, r.items, t)));
    }
    mergeValidEvaluated(e, t) {
      const { it: r, gen: s } = this;
      if (r.opts.unevaluated && (!0 !== r.props || !0 !== r.items))
        return s.if(t, () => this.mergeEvaluated(e, p)), !0;
    }
  }
  function Ar(e, t, r, s) {
    t = new Cr(e, r, t);
    "code" in r
      ? r.code(t, s)
      : t.$data && r.validate
      ? Ye(t, r)
      : "macro" in r
      ? (function (e, t) {
          const { gen: r, keyword: s, schema: a, parentSchema: o, it: n } = e;
          var i = t.macro.call(n.self, a, o, n),
            c = et(r, s, i);
          !1 !== n.opts.validateSchema && n.self.validateSchema(i, !0),
            (t = r.name("valid")),
            e.subschema(
              {
                schema: i,
                schemaPath: y,
                errSchemaPath: `${n.errSchemaPath}/${s}`,
                topSchemaRef: c,
                compositeRule: !0,
              },
              t
            ),
            e.pass(t, () => e.error(!0));
        })(t, r)
      : (r.compile || r.validate) && Ye(t, r);
  }
  const Ir = /^\/(?:[^~]|~0|~1)*$/,
    Tr = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  class Rr extends Error {
    constructor(e) {
      super("validation failed"),
        (this.errors = e),
        (this.ajv = this.validation = !0);
    }
  }
  class Or extends Error {
    constructor(e, t, r) {
      super(r || `can't resolve reference ${t} from id ${e}`),
        (this.missingRef = fr(e, t)),
        (this.missingSchema = mr(lr(this.missingRef)));
    }
  }
  class Dr {
    constructor(e) {
      var t;
      (this.refs = {}), (this.dynamicAnchors = {});
      let r;
      "object" == typeof e.schema && (r = e.schema),
        (this.schema = e.schema),
        (this.schemaId = e.schemaId),
        (this.root = e.root || this),
        (this.baseId =
          null !== (t = e.baseId) && void 0 !== t
            ? t
            : mr(null === r || void 0 === r ? void 0 : r[e.schemaId || "$id"])),
        (this.schemaPath = e.schemaPath),
        (this.localRefs = e.localRefs),
        (this.meta = e.meta),
        (this.$async = null === r || void 0 === r ? void 0 : r.$async),
        (this.refs = {});
    }
  }
  function qr(t) {
    var e = function (e) {
      for (const t of this._compilations)
        if (
          (function (e, t) {
            return (
              e.schema === t.schema &&
              e.root === t.root &&
              e.baseId === t.baseId
            );
          })(t, e)
        )
          return t;
    }.call(this, t);
    if (e) return e;
    var r = lr(t.root.baseId),
      { es5: s, lines: a } = this.opts.code,
      { ownProperties: e } = this.opts;
    const o = new G(this.scope, { es5: s, lines: a, ownProperties: e });
    let n;
    t.$async &&
      (n = o.scopeValue("Error", {
        ref: Rr,
        code: v`require("ajv/dist/runtime/validation_error").default`,
      }));
    e = o.scopeName("validate");
    t.validateName = e;
    r = {
      gen: o,
      allErrors: this.opts.allErrors,
      data: $e.data,
      parentData: $e.parentData,
      parentDataProperty: $e.parentDataProperty,
      dataNames: [$e.data],
      dataPathArr: [y],
      dataLevel: 0,
      dataTypes: [],
      definedProperties: new Set(),
      topSchemaRef: o.scopeValue(
        "schema",
        !0 === this.opts.code.source
          ? { ref: t.schema, code: g(t.schema) }
          : { ref: t.schema }
      ),
      validateName: e,
      ValidationError: n,
      schema: t.schema,
      schemaEnv: t,
      rootId: r,
      baseId: t.baseId || r,
      schemaPath: y,
      errSchemaPath: t.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: v`""`,
      opts: this.opts,
      self: this,
    };
    let i;
    try {
      this._compilations.add(t), vr(r), o.optimize(this.opts.code.optimize);
      var c,
        d,
        h = o.toString();
      (i = `${o.scopeRefs($e.scope)}return ${h}`),
        this.opts.code.process && (i = this.opts.code.process(i, t));
      const l = new Function(`${$e.self}`, `${$e.scope}`, i),
        u = l(this, this.scope.get());
      return (
        this.scope.value(e, { ref: u }),
        (u.errors = null),
        (u.schema = t.schema),
        (u.schemaEnv = t).$async && (u.$async = !0),
        !0 === this.opts.code.source &&
          (u.source = {
            validateName: e,
            validateCode: h,
            scopeValues: o._values,
          }),
        this.opts.unevaluated &&
          (({ props: c, items: d } = r),
          (u.evaluated = {
            props: c instanceof p ? void 0 : c,
            items: d instanceof p ? void 0 : d,
            dynamicProps: c instanceof p,
            dynamicItems: d instanceof p,
          }),
          u.source && (u.source.evaluated = g(u.evaluated))),
        (t.validate = u),
        t
      );
    } catch (e) {
      throw (
        (delete t.validate,
        delete t.validateName,
        i && this.logger.error("Error compiling schema, function code:", i),
        e)
      );
    } finally {
      this._compilations.delete(t);
    }
  }
  function zr(e, t, r) {
    r = fr(t, r);
    var s,
      a = e.refs[r];
    if (a) return a;
    let o = function (e, t) {
      let r;
      for (; "string" == typeof (r = this.refs[t]); ) t = r;
      return r || this.schemas[t] || Vr.call(this, e, t);
    }.call(this, e, r);
    return (
      void 0 === o &&
        ((a = null === (s = e.localRefs) || void 0 === s ? void 0 : s[r]),
        ({ schemaId: s } = this.opts),
        a && (o = new Dr({ schema: a, schemaId: s, root: e, baseId: t }))),
      void 0 !== o
        ? (e.refs[r] = function (e) {
            return cr(e.schema, this.opts.inlineRefs)
              ? e.schema
              : e.validate
              ? e
              : qr.call(this, e);
          }.call(this, o))
        : void 0
    );
  }
  function Vr(e, t) {
    var r = Vt.exports.parse(t),
      s = ur(r);
    let a = lr(e.baseId);
    if (0 < Object.keys(e.schema).length && s === a) return Lr.call(this, r, e);
    var o = mr(s),
      n = this.refs[o] || this.schemas[o];
    if ("string" == typeof n) {
      s = Vr.call(this, e, n);
      return "object" != typeof (null == s ? void 0 : s.schema)
        ? void 0
        : Lr.call(this, r, s);
    }
    if ("object" == typeof (null == n ? void 0 : n.schema)) {
      if ((n.validate || qr.call(this, n), o !== mr(t)))
        return Lr.call(this, r, n);
      var { schema: t } = n,
        { schemaId: r } = this.opts,
        n = t[r];
      return (
        n && (a = fr(a, n)),
        new Dr({ schema: t, schemaId: r, root: e, baseId: a })
      );
    }
  }
  const Fr = new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions",
  ]);
  function Lr(t, { baseId: r, schema: s, root: a }) {
    var e;
    if ("/" === (null === (e = t.fragment) || void 0 === e ? void 0 : e[0])) {
      for (const i of t.fragment.slice(1).split("/")) {
        if ("boolean" == typeof s) return;
        if (void 0 === (s = s[((o = i), ce(decodeURIComponent(o)))])) return;
        var o = "object" == typeof s && s[this.opts.schemaId];
        !Fr.has(i) && o && (r = fr(r, o));
      }
      let e;
      "boolean" != typeof s &&
        s.$ref &&
        !oe(s, this.RULES) &&
        ((n = fr(r, s.$ref)), (e = Vr.call(this, a, n)));
      var { schemaId: n } = this.opts;
      return (
        (e = e || new Dr({ schema: s, schemaId: n, root: a, baseId: r })),
        e.schema !== e.root.schema ? e : void 0
      );
    }
  }
  var qt =
      "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
    Ur = "Meta-schema for $data reference (JSON AnySchema extension proposal)",
    Mr = ["$data"],
    Kr = {
      $data: {
        type: "string",
        anyOf: [
          { format: "relative-json-pointer" },
          { format: "json-pointer" },
        ],
      },
    },
    Gr = Object.freeze({
      __proto__: null,
      $id: qt,
      description: Ur,
      type: "object",
      required: Mr,
      properties: Kr,
      additionalProperties: !1,
      default: {
        $id: qt,
        description: Ur,
        type: "object",
        required: Mr,
        properties: Kr,
        additionalProperties: !1,
      },
    });
  const Hr = ["removeAdditional", "useDefaults", "coerceTypes"],
    Wr = new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error",
    ]),
    Jr = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs:
        "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode:
        "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats:
        "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now.",
    },
    Br = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode:
        '"minLength"/"maxLength" account for unicode characters by default.',
    };
  class Qr {
    constructor(e = {}) {
      var t, r;
      (this.schemas = {}),
        (this.refs = {}),
        (this.formats = {}),
        (this._compilations = new Set()),
        (this._loading = {}),
        (this._cache = new Map()),
        (e = this.opts =
          {
            ...e,
            ...((a = e),
            (t = a.strict),
            (r = null === (s = a.code) || void 0 === s ? void 0 : s.optimize),
            (s = !0 === r || void 0 === r ? 1 : r || 0),
            {
              strictSchema:
                null ===
                  (r = null !== (r = a.strictSchema) && void 0 !== r ? r : t) ||
                void 0 === r ||
                r,
              strictNumbers:
                null ===
                  (r =
                    null !== (r = a.strictNumbers) && void 0 !== r ? r : t) ||
                void 0 === r ||
                r,
              strictTypes:
                null !==
                  (r = null !== (r = a.strictTypes) && void 0 !== r ? r : t) &&
                void 0 !== r
                  ? r
                  : "log",
              strictTuples:
                null !==
                  (r = null !== (r = a.strictTuples) && void 0 !== r ? r : t) &&
                void 0 !== r
                  ? r
                  : "log",
              strictRequired:
                null !==
                  (t =
                    null !== (r = a.strictRequired) && void 0 !== r ? r : t) &&
                void 0 !== t &&
                t,
              code: a.code ? { ...a.code, optimize: s } : { optimize: s },
              loopRequired:
                null !== (s = a.loopRequired) && void 0 !== s ? s : 200,
              loopEnum: null !== (s = a.loopEnum) && void 0 !== s ? s : 200,
              meta: null === (s = a.meta) || void 0 === s || s,
              messages: null === (s = a.messages) || void 0 === s || s,
              inlineRefs: null === (s = a.inlineRefs) || void 0 === s || s,
              schemaId: null !== (s = a.schemaId) && void 0 !== s ? s : "$id",
              addUsedSchema:
                null === (s = a.addUsedSchema) || void 0 === s || s,
              validateSchema:
                null === (s = a.validateSchema) || void 0 === s || s,
              validateFormats:
                null === (s = a.validateFormats) || void 0 === s || s,
              unicodeRegExp:
                null === (s = a.unicodeRegExp) || void 0 === s || s,
              int32range: null === (a = a.int32range) || void 0 === a || a,
            }),
          });
      var { es5: s, lines: a } = this.opts.code;
      (this.scope = new u({ scope: {}, prefixes: Wr, es5: s, lines: a })),
        (this.logger = (function (e) {
          if (!1 === e) return Xr;
          if (void 0 === e) return console;
          if (e.log && e.warn && e.error) return e;
          throw new Error("logger must implement log, warn and error methods");
        })(e.logger));
      s = e.validateFormats;
      (e.validateFormats = !1),
        (this.RULES = {
          types: {
            ...(a = {
              number: { type: "number", rules: [] },
              string: { type: "string", rules: [] },
              array: { type: "array", rules: [] },
              object: { type: "object", rules: [] },
            }),
            integer: !0,
            boolean: !0,
            null: !0,
          },
          rules: [{ rules: [] }, a.number, a.string, a.array, a.object],
          post: { rules: [] },
          all: {},
          keywords: {},
        }),
        Zr.call(this, Jr, e, "NOT SUPPORTED"),
        Zr.call(this, Br, e, "DEPRECATED", "warn"),
        (this._metaOpts = function () {
          const e = { ...this.opts };
          for (const t of Hr) delete e[t];
          return e;
        }.call(this)),
        e.formats &&
          function () {
            for (const t in this.opts.formats) {
              var e = this.opts.formats[t];
              e && this.addFormat(t, e);
            }
          }.call(this),
        this._addVocabularies(),
        this._addDefaultMetaSchema(),
        e.keywords &&
          function (e) {
            if (Array.isArray(e)) this.addVocabulary(e);
            else {
              this.logger.warn(
                "keywords option as map is deprecated, pass array"
              );
              for (const t in e) {
                const r = e[t];
                r.keyword || (r.keyword = t), this.addKeyword(r);
              }
            }
          }.call(this, e.keywords),
        "object" == typeof e.meta && this.addMetaSchema(e.meta),
        function () {
          var e = this.opts.schemas;
          if (e)
            if (Array.isArray(e)) this.addSchema(e);
            else for (const t in e) this.addSchema(e[t], t);
        }.call(this),
        (e.validateFormats = s);
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      var { $data: e, meta: t, schemaId: r } = this.opts;
      let s = Gr;
      "id" === r && ((s = { ...Gr }), (s.id = s.$id), delete s.$id),
        t && e && this.addMetaSchema(s, s[r], !1);
    }
    defaultMeta() {
      var { meta: e, schemaId: t } = this.opts;
      return (this.opts.defaultMeta =
        "object" == typeof e ? e[t] || e : void 0);
    }
    validate(e, t) {
      let r;
      if ("string" == typeof e) {
        if (((r = this.getSchema(e)), !r))
          throw new Error(`no schema with key or ref "${e}"`);
      } else r = this.compile(e);
      t = r(t);
      return "$async" in r || (this.errors = r.errors), t;
    }
    compile(e, t) {
      t = this._addSchema(e, t);
      return t.validate || this._compileSchemaEnv(t);
    }
    compileAsync(e, r) {
      if ("function" != typeof this.opts.loadSchema)
        throw new Error("options.loadSchema should be a function");
      const { loadSchema: s } = this.opts;
      return t.call(this, e, r);
      async function t(e, t) {
        await a.call(this, e.$schema);
        t = this._addSchema(e, t);
        return t.validate || o.call(this, t);
      }
      async function a(e) {
        e && !this.getSchema(e) && (await t.call(this, { $ref: e }, !0));
      }
      async function o(t) {
        try {
          return this._compileSchemaEnv(t);
        } catch (e) {
          if (!(e instanceof Or)) throw e;
          return (
            function ({ missingSchema: e, missingRef: t }) {
              if (this.refs[e])
                throw new Error(
                  `AnySchema ${e} is loaded but ${t} cannot be resolved`
                );
            }.call(this, e),
            await async function (e) {
              var t = await async function (e) {
                var t = this._loading[e];
                if (t) return t;
                try {
                  return await (this._loading[e] = s(e));
                } finally {
                  delete this._loading[e];
                }
              }.call(this, e);
              this.refs[e] || (await a.call(this, t.$schema));
              this.refs[e] || this.addSchema(t, e, r);
            }.call(this, e.missingSchema),
            o.call(this, t)
          );
        }
      }
    }
    addSchema(e, t, r, s = this.opts.validateSchema) {
      if (Array.isArray(e)) {
        for (const n of e) this.addSchema(n, void 0, r, s);
        return this;
      }
      let a;
      if ("object" == typeof e) {
        var { schemaId: o } = this.opts;
        if (((a = e[o]), void 0 !== a && "string" != typeof a))
          throw new Error(`schema ${o} must be string`);
      }
      return (
        (t = mr(t || a)),
        this._checkUnique(t),
        (this.schemas[t] = this._addSchema(e, r, t, s, !0)),
        this
      );
    }
    addMetaSchema(e, t, r = this.opts.validateSchema) {
      return this.addSchema(e, t, !0, r), this;
    }
    validateSchema(e, t) {
      if ("boolean" == typeof e) return !0;
      let r;
      if (((r = e.$schema), void 0 !== r && "string" != typeof r))
        throw new Error("$schema must be a string");
      if (((r = r || this.opts.defaultMeta || this.defaultMeta()), !r))
        return (
          this.logger.warn("meta-schema not available"), !(this.errors = null)
        );
      e = this.validate(r, e);
      if (!e && t) {
        t = "schema is invalid: " + this.errorsText();
        if ("log" !== this.opts.validateSchema) throw new Error(t);
        this.logger.error(t);
      }
      return e;
    }
    getSchema(e) {
      let t;
      for (; "string" == typeof (t = Yr.call(this, e)); ) e = t;
      if (void 0 === t) {
        var { schemaId: r } = this.opts,
          r = new Dr({ schema: {}, schemaId: r });
        if (((t = Vr.call(this, r, e)), !t)) return;
        this.refs[e] = t;
      }
      return t.validate || this._compileSchemaEnv(t);
    }
    removeSchema(e) {
      if (e instanceof RegExp)
        return (
          this._removeAllSchemas(this.schemas, e),
          this._removeAllSchemas(this.refs, e),
          this
        );
      switch (typeof e) {
        case "undefined":
          return (
            this._removeAllSchemas(this.schemas),
            this._removeAllSchemas(this.refs),
            this._cache.clear(),
            this
          );
        case "string":
          var t = Yr.call(this, e);
          return (
            "object" == typeof t && this._cache.delete(t.schema),
            delete this.schemas[e],
            delete this.refs[e],
            this
          );
        case "object":
          this._cache.delete(e);
          t = e[this.opts.schemaId];
          return (
            t && ((t = mr(t)), delete this.schemas[t], delete this.refs[t]),
            this
          );
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    addVocabulary(e) {
      for (const t of e) this.addKeyword(t);
      return this;
    }
    addKeyword(e, t) {
      let r;
      if ("string" == typeof e)
        (r = e),
          "object" == typeof t &&
            (this.logger.warn(
              "these parameters are deprecated, see docs for addKeyword"
            ),
            (t.keyword = r));
      else {
        if ("object" != typeof e || void 0 !== t)
          throw new Error("invalid addKeywords parameters");
        if (((t = e), (r = t.keyword), Array.isArray(r) && !r.length))
          throw new Error(
            "addKeywords: keyword must be string or non-empty array"
          );
      }
      if (
        (!function (e, t) {
          const { RULES: r } = this;
          if (
            (de(e, (e) => {
              if (r.keywords[e])
                throw new Error(`Keyword ${e} is already defined`);
              if (!es.test(e)) throw new Error(`Keyword ${e} has invalid name`);
            }),
            t && t.$data && !("code" in t || "validate" in t))
          )
            throw new Error(
              '$data keyword must have "code" or "validate" function'
            );
        }.call(this, r, t),
        !t)
      )
        return de(r, (e) => ts.call(this, e)), this;
      !function (e) {
        let { metaSchema: t } = e;
        void 0 !== t &&
          (e.$data && this.opts.$data && (t = ss(t)),
          (e.validateSchema = this.compile(t, !0)));
      }.call(this, t);
      const s = { ...t, type: Re(t.type), schemaType: Re(t.schemaType) };
      return (
        de(
          r,
          0 === s.type.length
            ? (e) => ts.call(this, e, s)
            : (t) => s.type.forEach((e) => ts.call(this, t, s, e))
        ),
        this
      );
    }
    getKeyword(e) {
      e = this.RULES.all[e];
      return "object" == typeof e ? e.definition : !!e;
    }
    removeKeyword(t) {
      const { RULES: e } = this;
      delete e.keywords[t], delete e.all[t];
      for (const s of e.rules) {
        var r = s.rules.findIndex((e) => e.keyword === t);
        0 <= r && s.rules.splice(r, 1);
      }
      return this;
    }
    addFormat(e, t) {
      return (
        "string" == typeof t && (t = new RegExp(t)), (this.formats[e] = t), this
      );
    }
    errorsText(
      e = this.errors,
      { separator: r = ", ", dataVar: t = "data" } = {}
    ) {
      return e && 0 !== e.length
        ? e
            .map((e) => `${t}${e.instancePath} ${e.message}`)
            .reduce((e, t) => e + r + t)
        : "No errors";
    }
    $dataMetaSchema(t, e) {
      var r = this.RULES.all;
      t = JSON.parse(JSON.stringify(t));
      for (const o of e) {
        let e = t;
        for (const n of o.split("/").slice(1)) e = e[n];
        for (const i in r) {
          var s,
            a = r[i];
          "object" == typeof a &&
            (({ $data: s } = a.definition),
            (a = e[i]),
            s && a && (e[i] = ss(a)));
        }
      }
      return t;
    }
    _removeAllSchemas(e, t) {
      for (const s in e) {
        var r = e[s];
        (t && !t.test(s)) ||
          ("string" == typeof r
            ? delete e[s]
            : r && !r.meta && (this._cache.delete(r.schema), delete e[s]));
      }
    }
    _addSchema(
      e,
      t,
      r,
      s = this.opts.validateSchema,
      a = this.opts.addUsedSchema
    ) {
      let o;
      var { schemaId: n } = this.opts;
      if ("object" == typeof e) o = e[n];
      else {
        if (this.opts.jtd) throw new Error("schema must be object");
        if ("boolean" != typeof e)
          throw new Error("schema must be object or boolean");
      }
      let i = this._cache.get(e);
      if (void 0 !== i) return i;
      var c = function (e) {
        if ("boolean" == typeof e) return {};
        const { schemaId: c } = this.opts;
        var t = mr(e[c]);
        const d = { "": t },
          h = lr(t, !1),
          l = {},
          u = new Set();
        return (
          zt(e, { allKeys: !0 }, (s, e, t, a) => {
            if (void 0 !== a) {
              const i = h + e;
              let r = d[a];
              function o(e) {
                if (((e = mr(r ? Vt.exports.resolve(r, e) : e)), u.has(e)))
                  throw m(e);
                u.add(e);
                let t = this.refs[e];
                return (
                  "string" == typeof t && (t = this.refs[t]),
                  "object" == typeof t
                    ? p(s, t.schema, e)
                    : e !== mr(i) &&
                      ("#" === e[0]
                        ? (p(s, l[e], e), (l[e] = s))
                        : (this.refs[e] = i)),
                  e
                );
              }
              function n(e) {
                if ("string" == typeof e) {
                  if (!yr.test(e)) throw new Error(`invalid anchor "${e}"`);
                  o.call(this, `#${e}`);
                }
              }
              "string" == typeof s[c] && (r = o.call(this, s[c])),
                n.call(this, s.$anchor),
                n.call(this, s.$dynamicAnchor),
                (d[e] = r);
            }
          }),
          l
        );
        function p(e, t, r) {
          if (void 0 !== t && !st(e, t)) throw m(r);
        }
        function m(e) {
          return new Error(`reference "${e}" resolves to more than one schema`);
        }
      }.call(this, e);
      return (
        (r = mr(o || r)),
        (i = new Dr({
          schema: e,
          schemaId: n,
          meta: t,
          baseId: r,
          localRefs: c,
        })),
        this._cache.set(i.schema, i),
        a &&
          !r.startsWith("#") &&
          (r && this._checkUnique(r), (this.refs[r] = i)),
        s && this.validateSchema(e, !0),
        i
      );
    }
    _checkUnique(e) {
      if (this.schemas[e] || this.refs[e])
        throw new Error(`schema with key or id "${e}" already exists`);
    }
    _compileSchemaEnv(e) {
      if ((e.meta ? this._compileMetaSchema(e) : qr.call(this, e), !e.validate))
        throw new Error("ajv implementation error");
      return e.validate;
    }
    _compileMetaSchema(e) {
      var t = this.opts;
      this.opts = this._metaOpts;
      try {
        qr.call(this, e);
      } finally {
        this.opts = t;
      }
    }
  }
  function Zr(e, t, r, s = "error") {
    for (const o in e) {
      var a = o;
      a in t && this.logger[s](`${r}: option ${o}. ${e[a]}`);
    }
  }
  function Yr(e) {
    return (e = mr(e)), this.schemas[e] || this.refs[e];
  }
  (Qr.ValidationError = Rr), (Qr.MissingRefError = Or);
  const Xr = { log() {}, warn() {}, error() {} };
  const es = /^[a-z_$][a-z0-9_$:-]*$/i;
  function ts(e, t, r) {
    var s = null == t ? void 0 : t.post;
    if (r && s) throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES: a } = this;
    let o = s ? a.post : a.rules.find(({ type: e }) => e === r);
    o || ((o = { type: r, rules: [] }), a.rules.push(o)),
      (a.keywords[e] = !0),
      t &&
        ((s = {
          keyword: e,
          definition: { ...t, type: Re(t.type), schemaType: Re(t.schemaType) },
        }),
        t.before
          ? function (e, t, r) {
              var s = e.rules.findIndex((e) => e.keyword === r);
              0 <= s
                ? e.rules.splice(s, 0, t)
                : (e.rules.push(t),
                  this.logger.warn(`rule ${r} is not defined`));
            }.call(this, o, s, t.before)
          : o.rules.push(s),
        (a.all[e] = s),
        null !== (t = t.implements) &&
          void 0 !== t &&
          t.forEach((e) => this.addKeyword(e)));
  }
  const rs = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
  };
  function ss(e) {
    return { anyOf: [e, rs] };
  }
  function as(e, t) {
    const { gen: r } = e;
    return t.validate
      ? r.scopeValue("validate", { ref: t.validate })
      : v`${r.scopeValue("wrapper", { ref: t })}.validate`;
  }
  function os(e, r, s, t) {
    const { gen: a, it: o } = e,
      { allErrors: n, schemaEnv: i, opts: c } = o,
      d = c.passContext ? $e.this : y;
    function h(e) {
      e = v`${e}.errors`;
      a.assign(
        $e.vErrors,
        v`${$e.vErrors} === null ? ${e} : ${$e.vErrors}.concat(${e})`
      ),
        a.assign($e.errors, v`${$e.vErrors}.length`);
    }
    function l(e) {
      var t, r;
      o.opts.unevaluated &&
        ((t =
          null === (r = null == s ? void 0 : s.validate) || void 0 === r
            ? void 0
            : r.evaluated),
        !0 !== o.props &&
          (t && !t.dynamicProps
            ? void 0 !== t.props && (o.props = le.props(a, t.props, o.props))
            : ((r = a.var("props", v`${e}.evaluated.props`)),
              (o.props = le.props(a, r, o.props, p)))),
        !0 !== o.items &&
          (t && !t.dynamicItems
            ? void 0 !== t.items && (o.items = le.items(a, t.items, o.items))
            : ((e = a.var("items", v`${e}.evaluated.items`)),
              (o.items = le.items(a, e, o.items, p)))));
    }
    t
      ? (function () {
          if (!i.$async)
            throw new Error("async schema referenced by sync schema");
          const t = a.let("valid");
          a.try(
            () => {
              a.code(v`await ${Be(e, r, d)}`), l(r), n || a.assign(t, !0);
            },
            (e) => {
              a.if(v`!(${e} instanceof ${o.ValidationError})`, () =>
                a.throw(e)
              ),
                h(e),
                n || a.assign(t, !1);
            }
          ),
            e.ok(t);
        })()
      : e.result(
          Be(e, r, d),
          () => l(r),
          () => h(r)
        );
  }
  var ns = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      {
        keyword: "id",
        code() {
          throw new Error(
            'NOT SUPPORTED: keyword "id", use "$id" for schema ID'
          );
        },
      },
      {
        keyword: "$ref",
        schemaType: "string",
        code(t) {
          const { gen: r, schema: e, it: s } = t,
            { baseId: a, schemaEnv: o, validateName: n, opts: i, self: c } = s,
            { root: d } = o;
          if (("#" === e || "#/" === e) && a === d.baseId)
            return (function () {
              if (o === d) return os(t, n, o, o.$async);
              var e = r.scopeValue("root", { ref: d });
              return os(t, v`${e}.validate`, d, d.$async);
            })();
          var h,
            l,
            u,
            p,
            m,
            f = zr.call(c, d, a, e);
          if (void 0 === f) throw new Or(a, e);
          return f instanceof Dr
            ? ((l = as(t, (h = f))), void os(t, l, h, h.$async))
            : ((u = f),
              (p = r.scopeValue(
                "schema",
                !0 === i.code.source ? { ref: u, code: g(u) } : { ref: u }
              )),
              (m = r.name("valid")),
              (p = t.subschema(
                {
                  schema: u,
                  dataTypes: [],
                  schemaPath: y,
                  topSchemaRef: p,
                  errSchemaPath: e,
                },
                m
              )),
              t.mergeEvaluated(p),
              void t.ok(m));
        },
      },
    ],
    is = E;
  const cs = {
    maximum: { okStr: "<=", ok: is.LTE, fail: is.GT },
    minimum: { okStr: ">=", ok: is.GTE, fail: is.LT },
    exclusiveMaximum: { okStr: "<", ok: is.LT, fail: is.GTE },
    exclusiveMinimum: { okStr: ">", ok: is.GT, fail: is.LTE },
  };
  var at = {
      message: ({ keyword: e, schemaCode: t }) =>
        f`must be ${cs[e].okStr} ${t}`,
      params: ({ keyword: e, schemaCode: t }) =>
        v`{comparison: ${cs[e].okStr}, limit: ${t}}`,
    },
    ds = {
      keyword: Object.keys(cs),
      type: "number",
      schemaType: "number",
      $data: !0,
      error: at,
      code(e) {
        var { keyword: t, data: r, schemaCode: s } = e;
        e.fail$data(v`${r} ${cs[t].fail} ${s} || isNaN(${r})`);
      },
    },
    hs = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: !0,
      error: {
        message: ({ schemaCode: e }) => f`must be multiple of ${e}`,
        params: ({ schemaCode: e }) => v`{multipleOf: ${e}}`,
      },
      code(e) {
        const { gen: t, data: r, schemaCode: s, it: a } = e;
        var o = a.opts.multipleOfPrecision,
          n = t.let("res"),
          o = o
            ? v`Math.abs(Math.round(${n}) - ${n}) > 1e-${o}`
            : v`${n} !== parseInt(${n})`;
        e.fail$data(v`(${s} === 0 || (${n} = ${r}/${s}, ${o}))`);
      },
    };
  function ls(e) {
    var t = e.length;
    let r = 0,
      s = 0,
      a;
    for (; s < t; )
      r++,
        (a = e.charCodeAt(s++)),
        55296 <= a &&
          a <= 56319 &&
          s < t &&
          ((a = e.charCodeAt(s)), 56320 == (64512 & a) && s++);
    return r;
  }
  ls.code = 'require("ajv/dist/runtime/ucs2length").default';
  (qt = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: e, schemaCode: t }) {
        return f`must NOT have ${
          "maxLength" === e ? "more" : "fewer"
        } than ${t} characters`;
      },
      params: ({ schemaCode: e }) => v`{limit: ${e}}`,
    },
    code(e) {
      var { keyword: t, data: r, schemaCode: s, it: a } = e,
        t = "maxLength" === t ? E.GT : E.LT,
        r = !1 === a.opts.unicode ? v`${r}.length` : v`${fe(e.gen, ls)}(${r})`;
      e.fail$data(v`${r} ${t} ${s}`);
    },
  }),
    (Ur = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: !0,
      error: {
        message: ({ schemaCode: e }) => f`must match pattern "${e}"`,
        params: ({ schemaCode: e }) => v`{pattern: ${e}}`,
      },
      code(e) {
        var { data: t, $data: r, schema: s, schemaCode: a, it: o } = e,
          o = o.opts.unicodeRegExp ? "u" : "",
          s = r ? v`(new RegExp(${a}, ${o}))` : Qe(e, s);
        e.fail$data(v`!${s}.test(${t})`);
      },
    }),
    (Mr = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: !0,
      error: {
        message({ keyword: e, schemaCode: t }) {
          return f`must NOT have ${
            "maxProperties" === e ? "more" : "fewer"
          } than ${t} items`;
        },
        params: ({ schemaCode: e }) => v`{limit: ${e}}`,
      },
      code(e) {
        var { keyword: t, data: r, schemaCode: s } = e,
          t = "maxProperties" === t ? E.GT : E.LT;
        e.fail$data(v`Object.keys(${r}).length ${t} ${s}`);
      },
    }),
    (Kr = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: !0,
      error: {
        message: ({ params: { missingProperty: e } }) =>
          f`must have required property '${e}'`,
        params: ({ params: { missingProperty: e } }) =>
          v`{missingProperty: ${e}}`,
      },
      code(r) {
        const {
            gen: s,
            schema: a,
            schemaCode: o,
            data: n,
            $data: i,
            it: e,
          } = r,
          { opts: c } = e;
        if (i || 0 !== a.length) {
          const l = a.length >= c.loopRequired;
          if (
            ((e.allErrors
              ? function () {
                  if (l || i) r.block$data(y, h);
                  else for (const e of a) Ue(r, e);
                }
              : function () {
                  const e = s.let("missing");
                  if (l || i) {
                    const t = s.let("valid", !0);
                    r.block$data(t, () =>
                      (function (e, t) {
                        r.setParams({ missingProperty: e }),
                          s.forOf(
                            e,
                            o,
                            () => {
                              s.assign(t, He(s, n, e, c.ownProperties)),
                                s.if(B(t), () => {
                                  r.error(), s.break();
                                });
                            },
                            y
                          );
                      })(e, t)
                    ),
                      r.ok(t);
                  } else s.if(Me(r, a, e)), Ke(r, e), s.else();
                })(),
            c.strictRequired)
          ) {
            var t,
              d = r.parentSchema.properties;
            const { definedProperties: u } = r.it;
            for (const p of a)
              void 0 !== (null == d ? void 0 : d[p]) ||
                u.has(p) ||
                ((t = e.schemaEnv.baseId + e.errSchemaPath),
                ve(
                  e,
                  `required property "${p}" is not defined at "${t}" (strictRequired)`,
                  e.opts.strictRequired
                ));
          }
          function h() {
            s.forOf("prop", o, (e) => {
              r.setParams({ missingProperty: e }),
                s.if(We(s, n, e, c.ownProperties), () => r.error());
            });
          }
        }
      },
    }),
    (is = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: !0,
      error: {
        message({ keyword: e, schemaCode: t }) {
          return f`must NOT have ${
            "maxItems" === e ? "more" : "fewer"
          } than ${t} items`;
        },
        params: ({ schemaCode: e }) => v`{limit: ${e}}`,
      },
      code(e) {
        var { keyword: t, data: r, schemaCode: s } = e,
          t = "maxItems" === t ? E.GT : E.LT;
        e.fail$data(v`${r}.length ${t} ${s}`);
      },
    });
  rt.code = 'require("ajv/dist/runtime/equal").default';
  const us = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: e } }) =>
        f`must NOT have more than ${e} items`,
      params: ({ params: { len: e } }) => v`{limit: ${e}}`,
    },
    code(e) {
      var { parentSchema: t, it: r } = e,
        { items: t } = t;
      Array.isArray(t)
        ? ps(e, t)
        : ve(
            r,
            '"additionalItems" is ignored when "items" is not an array of schemas'
          );
    },
  };
  function ps(r, e) {
    const { gen: s, schema: t, data: a, keyword: o, it: n } = r;
    n.items = !0;
    const i = s.const("len", v`${a}.length`);
    if (!1 === t)
      r.setParams({ len: e.length }), r.pass(v`${i} <= ${e.length}`);
    else if ("object" == typeof t && !se(n, t)) {
      const c = s.var("valid", v`${i} <= ${e.length}`);
      s.if(B(c), () =>
        (function (t) {
          s.forRange("i", e.length, i, (e) => {
            r.subschema({ keyword: o, dataProp: e, dataPropType: b.Num }, t),
              n.allErrors || s.if(B(t), () => s.break());
          });
        })(c)
      ),
        r.ok(c);
    }
  }
  const ms = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(e) {
      const { schema: t, it: r } = e;
      if (Array.isArray(t)) return fs(e, "additionalItems", t);
      (r.items = !0), se(r, t) || e.ok(Ze(e));
    },
  };
  function fs(r, a, o = r.schema) {
    const { gen: s, parentSchema: e, data: t, keyword: n, it: i } = r;
    !(function (e) {
      var { opts: t, errSchemaPath: r } = i,
        s = o.length,
        e = s === e.minItems && (s === e.maxItems || !1 === e[a]);
      t.strictTuples &&
        !e &&
        ((r = `"${n}" is ${s}-tuple, but minItems or maxItems/${a} are not specified or different at path "${r}"`),
        ve(i, r, t.strictTuples));
    })(e),
      i.opts.unevaluated &&
        o.length &&
        !0 !== i.items &&
        (i.items = le.items(s, o.length, i.items));
    const c = s.name("valid"),
      d = s.const("len", v`${t}.length`);
    o.forEach((e, t) => {
      se(i, e) ||
        (s.if(v`${d} > ${t}`, () =>
          r.subschema({ keyword: n, schemaProp: t, dataProp: t }, c)
        ),
        r.ok(c));
    });
  }
  const ys = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (e) => fs(e, "items"),
    },
    vs = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error: {
        message: ({ params: { len: e } }) =>
          f`must NOT have more than ${e} items`,
        params: ({ params: { len: e } }) => v`{limit: ${e}}`,
      },
      code(e) {
        const { schema: t, parentSchema: r, it: s } = e;
        var { prefixItems: a } = r;
        (s.items = !0), se(s, t) || (a ? ps(e, a) : e.ok(Ze(e)));
      },
    },
    $s = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: !0,
      error: {
        message: ({ params: { min: e, max: t } }) =>
          void 0 === t
            ? f`must contain at least ${e} valid item(s)`
            : f`must contain at least ${e} and no more than ${t} valid item(s)`,
        params: ({ params: { min: e, max: t } }) =>
          void 0 === t
            ? v`{minContains: ${e}}`
            : v`{minContains: ${e}, maxContains: ${t}}`,
      },
      code(s) {
        const { gen: a, schema: e, parentSchema: t, data: r, it: o } = s;
        let n, i;
        var { minContains: c, maxContains: d } = t;
        o.opts.next ? ((n = void 0 === c ? 1 : c), (i = d)) : (n = 1);
        const h = a.const("len", v`${r}.length`);
        if ((s.setParams({ min: n, max: i }), void 0 !== i || 0 !== n)) {
          if (void 0 !== i && n > i)
            return (
              ve(o, '"minContains" > "maxContains" is always invalid'),
              void s.fail()
            );
          if (se(o, e)) {
            let e = v`${h} >= ${n}`;
            return (
              void 0 !== i && (e = v`${e} && ${h} <= ${i}`), void s.pass(e)
            );
          }
          o.items = !0;
          const u = a.name("valid");
          if (void 0 === i && 1 === n) l(u, () => a.if(u, () => a.break()));
          else {
            a.let(u, !1);
            const p = a.name("_valid"),
              m = a.let("count", 0);
            l(p, () =>
              a.if(p, () =>
                (function (e) {
                  a.code(v`${e}++`),
                    void 0 === i
                      ? a.if(v`${e} >= ${n}`, () => a.assign(u, !0).break())
                      : (a.if(v`${e} > ${i}`, () => a.assign(u, !1).break()),
                        1 === n
                          ? a.assign(u, !0)
                          : a.if(v`${e} >= ${n}`, () => a.assign(u, !0)));
                })(m)
              )
            );
          }
          function l(t, r) {
            a.forRange("i", 0, h, (e) => {
              s.subschema(
                {
                  keyword: "contains",
                  dataProp: e,
                  dataPropType: b.Num,
                  compositeRule: !0,
                },
                t
              ),
                r();
            });
          }
          s.result(u, () => s.reset());
        } else
          ve(
            o,
            '"minContains" == 0 without "maxContains": "contains" keyword ignored'
          );
      },
    };
  at = {
    message: ({ params: { property: e, depsCount: t, deps: r } }) => {
      return f`must have ${
        1 === t ? "property" : "properties"
      } ${r} when property ${e} is present`;
    },
    params: ({
      params: { property: e, depsCount: t, deps: r, missingProperty: s },
    }) => v`{property: ${e},
    missingProperty: ${s},
    depsCount: ${t},
    deps: ${r}}`,
  };
  const gs = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: at,
    code(e) {
      var [t, r] = (function ({ schema: e }) {
        var t = {},
          r = {};
        for (const s in e)
          if ("__proto__" !== s) {
            const a = Array.isArray(e[s]) ? t : r;
            a[s] = e[s];
          }
        return [t, r];
      })(e);
      ws(e, t), bs(e, r);
    },
  };
  function ws(t, e = t.schema) {
    const { gen: r, data: s, it: a } = t;
    if (0 !== Object.keys(e).length) {
      var o,
        n = r.let("missing");
      for (const i in e) {
        const c = e[i];
        0 !== c.length &&
          ((o = He(r, s, i, a.opts.ownProperties)),
          t.setParams({ property: i, depsCount: c.length, deps: c.join(", ") }),
          a.allErrors
            ? r.if(o, () => {
                for (const e of c) Ue(t, e);
              })
            : (r.if(v`${o} && (${Me(t, c, n)})`), Ke(t, n), r.else()));
      }
    }
  }
  function bs(t, e = t.schema) {
    const { gen: r, data: s, keyword: a, it: o } = t,
      n = r.name("valid");
    for (const i in e)
      se(o, e[i]) ||
        (r.if(
          He(r, s, i, o.opts.ownProperties),
          () => {
            var e = t.subschema({ keyword: a, schemaProp: i }, n);
            t.mergeValidEvaluated(e, n);
          },
          () => r.var(n, !0)
        ),
        t.ok(n));
  }
  const Es = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error: {
        message: "property name must be valid",
        params: ({ params: e }) => v`{propertyName: ${e.propertyName}}`,
      },
      code(t) {
        const { gen: r, schema: e, data: s, it: a } = t;
        if (!se(a, e)) {
          const o = r.name("valid");
          r.forIn("key", s, (e) => {
            t.setParams({ propertyName: e }),
              t.subschema(
                {
                  keyword: "propertyNames",
                  data: e,
                  dataTypes: ["string"],
                  propertyName: e,
                  compositeRule: !0,
                },
                o
              ),
              r.if(B(o), () => {
                t.error(!0), a.allErrors || r.break();
              });
          }),
            t.ok(o);
        }
      },
    },
    Ss = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: !0,
      trackErrors: !0,
      error: {
        message: "must NOT have additional properties",
        params: ({ params: e }) =>
          v`{additionalProperty: ${e.additionalProperty}}`,
      },
      code(s) {
        const {
          gen: a,
          schema: r,
          parentSchema: o,
          data: t,
          errsCount: e,
          it: n,
        } = s;
        if (!e) throw new Error("ajv implementation error");
        const { allErrors: i, opts: c } = n;
        if (((n.props = !0), "all" === c.removeAdditional || !se(n, r))) {
          const u = Je(o.properties),
            p = Je(o.patternProperties);
          function d(e) {
            a.code(v`delete ${t}[${e}]`);
          }
          function h(e) {
            var t;
            {
              if (
                !(
                  "all" === c.removeAdditional ||
                  (c.removeAdditional && !1 === r)
                )
              )
                return !1 === r
                  ? (s.setParams({ additionalProperty: e }),
                    s.error(),
                    void (i || a.break()))
                  : void (
                      "object" != typeof r ||
                      se(n, r) ||
                      ((t = a.name("valid")),
                      "failing" === c.removeAdditional
                        ? (l(e, t, !1),
                          a.if(B(t), () => {
                            s.reset(), d(e);
                          }))
                        : (l(e, t), i || a.if(B(t), () => a.break())))
                    );
              d(e);
            }
          }
          function l(e, t, r) {
            e = {
              keyword: "additionalProperties",
              dataProp: e,
              dataPropType: b.Str,
            };
            !1 === r &&
              Object.assign(e, {
                compositeRule: !0,
                createErrors: !1,
                allErrors: !1,
              }),
              s.subschema(e, t);
          }
          a.forIn("key", t, (e) => {
            u.length || p.length
              ? a.if(
                  (function (t) {
                    let e;
                    {
                      var r;
                      e =
                        8 < u.length
                          ? ((r = ne(n, o.properties, "properties")),
                            Ge(a, r, t))
                          : u.length
                          ? X(...u.map((e) => v`${t} === ${e}`))
                          : y;
                    }
                    p.length &&
                      (e = X(e, ...p.map((e) => v`${Qe(s, e)}.test(${t})`)));
                    return B(e);
                  })(e),
                  () => h(e)
                )
              : h(e);
          }),
            s.ok(v`${e} === ${$e.errors}`);
        }
      },
    },
    ks = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(t) {
        const { gen: e, schema: r, parentSchema: s, data: a, it: o } = t;
        "all" === o.opts.removeAdditional &&
          void 0 === s.additionalProperties &&
          Ss.code(new Cr(o, Ss, "additionalProperties"));
        const n = Je(r);
        for (const h of n) o.definedProperties.add(h);
        o.opts.unevaluated &&
          n.length &&
          !0 !== o.props &&
          (o.props = le.props(e, re(n), o.props));
        var i,
          c = n.filter((e) => !se(o, r[e]));
        if (0 !== c.length) {
          const l = e.name("valid");
          for (const u of c)
            (i = u),
              o.opts.useDefaults && !o.compositeRule && void 0 !== r[i].default
                ? d(u)
                : (e.if(He(e, a, u, o.opts.ownProperties)),
                  d(u),
                  o.allErrors || e.else().var(l, !0),
                  e.endIf()),
              t.it.definedProperties.add(u),
              t.ok(l);
          function d(e) {
            t.subschema(
              { keyword: "properties", schemaProp: e, dataProp: e },
              l
            );
          }
        }
      },
    },
    _s = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(s) {
        const { gen: a, schema: t, data: e, parentSchema: r, it: o } = s;
        var { opts: n } = o;
        const i = Je(t),
          c = i.filter((e) => se(o, t[e]));
        if (
          0 !== i.length &&
          (c.length !== i.length || (o.opts.unevaluated && !0 !== o.props))
        ) {
          const h =
              n.strictSchema && !n.allowMatchingProperties && r.properties,
            l = a.name("valid");
          !0 === o.props || o.props instanceof p || (o.props = ue(a, o.props));
          const { props: u } = o;
          function d(r) {
            a.forIn("key", e, (t) => {
              a.if(v`${Qe(s, r)}.test(${t})`, () => {
                var e = c.includes(r);
                e ||
                  s.subschema(
                    {
                      keyword: "patternProperties",
                      schemaProp: r,
                      dataProp: t,
                      dataPropType: b.Str,
                    },
                    l
                  ),
                  o.opts.unevaluated && !0 !== u
                    ? a.assign(v`${u}[${t}]`, !0)
                    : e || o.allErrors || a.if(B(l), () => a.break());
              });
            });
          }
          !(function () {
            for (const e of i)
              h &&
                (function (e) {
                  for (const t in h)
                    new RegExp(e).test(t) &&
                      ve(
                        o,
                        `property ${t} matches pattern ${e} (use allowMatchingProperties)`
                      );
                })(e),
                o.allErrors ? d(e) : (a.var(l, !0), d(e), a.if(l));
          })();
        }
      },
    },
    Ps = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: !0,
      code(e) {
        const { gen: t, schema: r, it: s } = e;
        var a;
        se(s, r)
          ? e.fail()
          : ((a = t.name("valid")),
            e.subschema(
              {
                keyword: "not",
                compositeRule: !0,
                createErrors: !1,
                allErrors: !1,
              },
              a
            ),
            e.failResult(
              a,
              () => e.reset(),
              () => e.error()
            ));
      },
      error: { message: "must NOT be valid" },
    },
    js = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: !0,
      code: function (r) {
        const { gen: s, schema: e, keyword: a, it: t } = r;
        if (!Array.isArray(e)) throw new Error("ajv implementation error");
        if (!e.some((e) => se(t, e)) || t.opts.unevaluated) {
          const o = s.let("valid", !1),
            n = s.name("_valid");
          s.block(() =>
            e.forEach((e, t) => {
              t = r.subschema(
                { keyword: a, schemaProp: t, compositeRule: !0 },
                n
              );
              s.assign(o, v`${o} || ${n}`),
                r.mergeValidEvaluated(t, n) || s.if(B(o));
            })
          ),
            r.result(
              o,
              () => r.reset(),
              () => r.error(!0)
            );
        }
      },
      error: { message: "must match a schema in anyOf" },
    },
    Ns = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: !0,
      error: {
        message: "must match exactly one schema in oneOf",
        params: ({ params: e }) => v`{passingSchemas: ${e.passing}}`,
      },
      code(s) {
        const { gen: a, schema: e, parentSchema: t, it: o } = s;
        if (!Array.isArray(e)) throw new Error("ajv implementation error");
        if (!o.opts.discriminator || !t.discriminator) {
          const r = e,
            n = a.let("valid", !1),
            i = a.let("passing", null),
            c = a.name("_valid");
          s.setParams({ passing: i }),
            a.block(function () {
              r.forEach((e, t) => {
                let r;
                se(o, e)
                  ? a.var(c, !0)
                  : (r = s.subschema(
                      { keyword: "oneOf", schemaProp: t, compositeRule: !0 },
                      c
                    )),
                  0 < t &&
                    a
                      .if(v`${c} && ${n}`)
                      .assign(n, !1)
                      .assign(i, v`[${i}, ${t}]`)
                      .else(),
                  a.if(c, () => {
                    a.assign(n, !0),
                      a.assign(i, t),
                      r && s.mergeEvaluated(r, p);
                  });
              });
            }),
            s.result(
              n,
              () => s.reset(),
              () => s.error(!0)
            );
        }
      },
    },
    xs = {
      keyword: "allOf",
      schemaType: "array",
      code(r) {
        const { gen: e, schema: t, it: s } = r;
        if (!Array.isArray(t)) throw new Error("ajv implementation error");
        const a = e.name("valid");
        t.forEach((e, t) => {
          se(s, e) ||
            ((t = r.subschema({ keyword: "allOf", schemaProp: t }, a)),
            r.ok(a),
            r.mergeEvaluated(t));
        });
      },
    },
    Cs = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: !0,
      error: {
        message: ({ params: e }) => f`must match "${e.ifClause}" schema`,
        params: ({ params: e }) => v`{failingKeyword: ${e.ifClause}}`,
      },
      code(s) {
        const { gen: a, parentSchema: e, it: t } = s;
        void 0 === e.then &&
          void 0 === e.else &&
          ve(t, '"if" without "then" and "else" is ignored');
        var r,
          o = As(t, "then"),
          n = As(t, "else");
        if (o || n) {
          const c = a.let("valid", !0),
            d = a.name("_valid");
          function i(t, r) {
            return () => {
              var e = s.subschema({ keyword: t }, d);
              a.assign(c, d),
                s.mergeValidEvaluated(e, c),
                r ? a.assign(r, v`${t}`) : s.setParams({ ifClause: t });
            };
          }
          (r = s.subschema(
            {
              keyword: "if",
              compositeRule: !0,
              createErrors: !1,
              allErrors: !1,
            },
            d
          )),
            s.mergeEvaluated(r),
            s.reset(),
            o && n
              ? ((n = a.let("ifClause")),
                s.setParams({ ifClause: n }),
                a.if(d, i("then", n), i("else", n)))
              : o
              ? a.if(d, i("then"))
              : a.if(B(d), i("else")),
            s.pass(c, () => s.error(!0));
        }
      },
    };
  function As(e, t) {
    t = e.schema[t];
    return void 0 !== t && !se(e, t);
  }
  const Is = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: e, parentSchema: t, it: r }) {
      void 0 === t.if && ve(r, `"${e}" without "if" is ignored`);
    },
  };
  var Ts,
    rt = [
      {
        keyword: "format",
        type: ["number", "string"],
        schemaType: "string",
        $data: !0,
        error: {
          message: ({ schemaCode: e }) => f`must match format "${e}"`,
          params: ({ schemaCode: e }) => v`{format: ${e}}`,
        },
        code(a, o) {
          const {
              gen: n,
              data: i,
              $data: e,
              schema: c,
              schemaCode: d,
              it: t,
            } = a,
            { opts: h, errSchemaPath: l, schemaEnv: u, self: p } = t;
          h.validateFormats &&
            (e
              ? function () {
                  const e = n.scopeValue("formats", {
                      ref: p.formats,
                      code: h.code.formats,
                    }),
                    t = n.const("fDef", v`${e}[${d}]`),
                    r = n.let("fType"),
                    s = n.let("format");
                  n.if(
                    v`typeof ${t} == "object" && !(${t} instanceof RegExp)`,
                    () =>
                      n
                        .assign(r, v`${t}.type || "string"`)
                        .assign(s, v`${t}.validate`),
                    () => n.assign(r, v`"string"`).assign(s, t)
                  ),
                    a.fail$data(
                      X(
                        !1 === h.strictSchema ? y : v`${d} && !${s}`,
                        (function () {
                          var e = u.$async
                              ? v`(${t}.async ? await ${s}(${i}) : ${s}(${i}))`
                              : v`${s}(${i})`,
                            e = v`(typeof ${s} == "function" ? ${e} : ${s}.test(${i}))`;
                          return v`${s} && ${s} !== true && ${r} === ${o} && !${e}`;
                        })()
                      )
                    );
                }
              : function () {
                  const e = p.formats[c];
                  if (e) {
                    if (!0 !== e) {
                      const [t, r, s] = (function (e) {
                        var t =
                            e instanceof RegExp
                              ? (function (e) {
                                  return new m(e.toString());
                                })(e)
                              : h.code.formats
                              ? v`${h.code.formats}${w(c)}`
                              : void 0,
                          t = n.scopeValue("formats", {
                            key: c,
                            ref: e,
                            code: t,
                          });
                        return "object" != typeof e || e instanceof RegExp
                          ? ["string", e, t]
                          : [e.type || "string", e.validate, v`${t}.validate`];
                      })(e);
                      t === o &&
                        a.pass(
                          (function () {
                            if (
                              "object" != typeof e ||
                              e instanceof RegExp ||
                              !e.async
                            )
                              return "function" == typeof r
                                ? v`${s}(${i})`
                                : v`${s}.test(${i})`;
                            if (!u.$async)
                              throw new Error("async format in sync schema");
                            return v`await ${s}(${i})`;
                          })()
                        );
                    }
                  } else
                    !(function () {
                      if (!1 !== h.strictSchema) throw new Error(e());
                      function e() {
                        return `unknown format "${c}" ignored in schema at path "${l}"`;
                      }
                      p.logger.warn(e());
                    })();
                })();
        },
      },
    ];
  const Rs = [
    ns,
    [
      ds,
      hs,
      qt,
      Ur,
      Mr,
      Kr,
      is,
      {
        keyword: "uniqueItems",
        type: "array",
        schemaType: "boolean",
        $data: !0,
        error: {
          message: ({ params: { i: e, j: t } }) =>
            f`must NOT have duplicate items (items ## ${t} and ${e} are identical)`,
          params: ({ params: { i: e, j: t } }) => v`{i: ${e}, j: ${t}}`,
        },
        code(o) {
          const {
            gen: n,
            data: i,
            $data: e,
            schema: t,
            parentSchema: r,
            schemaCode: s,
            it: c,
          } = o;
          if (e || t) {
            const d = n.let("valid"),
              h = r.items ? Te(r.items) : [];
            o.block$data(
              d,
              function () {
                const e = n.let("i", v`${i}.length`),
                  t = n.let("j");
                o.setParams({ i: e, j: t }),
                  n.assign(d, !0),
                  n.if(v`${e} > 1`, () =>
                    ((function () {
                      return (
                        0 < h.length &&
                        !h.some((e) => "object" === e || "array" === e)
                      );
                    })()
                      ? function (e, t) {
                          const r = n.name("item"),
                            s = ze(h, r, c.opts.strictNumbers, Ne.Wrong),
                            a = n.const("indices", v`{}`);
                          n.for(v`;${e}--;`, () => {
                            n.let(r, v`${i}[${e}]`),
                              n.if(s, v`continue`),
                              1 < h.length &&
                                n.if(
                                  v`typeof ${r} == "string"`,
                                  v`${r} += "_"`
                                ),
                              n
                                .if(v`typeof ${a}[${r}] == "number"`, () => {
                                  n.assign(t, v`${a}[${r}]`),
                                    o.error(),
                                    n.assign(d, !1).break();
                                })
                                .code(v`${a}[${r}] = ${e}`);
                          });
                        }
                      : function (e, t) {
                          const r = fe(n, st),
                            s = n.name("outer");
                          n.label(s).for(v`;${e}--;`, () =>
                            n.for(v`${t} = ${e}; ${t}--;`, () =>
                              n.if(v`${r}(${i}[${e}], ${i}[${t}])`, () => {
                                o.error(), n.assign(d, !1).break(s);
                              })
                            )
                          );
                        })(e, t)
                  );
              },
              v`${s} === false`
            ),
              o.ok(d);
          }
        },
      },
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      {
        keyword: "const",
        $data: !0,
        error: {
          message: "must be equal to constant",
          params: ({ schemaCode: e }) => v`{allowedValue: ${e}}`,
        },
        code(e) {
          var { gen: t, data: r, $data: s, schemaCode: a, schema: o } = e;
          s || (o && "object" == typeof o)
            ? e.fail$data(v`!${fe(t, st)}(${r}, ${a})`)
            : e.fail(v`${o} !== ${r}`);
        },
      },
      {
        keyword: "enum",
        schemaType: "array",
        $data: !0,
        error: {
          message: "must be equal to one of the allowed values",
          params: ({ schemaCode: e }) => v`{allowedValues: ${e}}`,
        },
        code(e) {
          const {
            gen: t,
            data: s,
            $data: r,
            schema: a,
            schemaCode: o,
            it: n,
          } = e;
          if (!r && 0 === a.length)
            throw new Error("enum must have non-empty array");
          var i = a.length >= n.opts.loopEnum;
          const c = fe(t, st);
          let d;
          if (i || r)
            (d = t.let("valid")),
              e.block$data(d, function () {
                t.assign(d, !1),
                  t.forOf("v", o, (e) =>
                    t.if(v`${c}(${s}, ${e})`, () => t.assign(d, !0).break())
                  );
              });
          else {
            if (!Array.isArray(a)) throw new Error("ajv implementation error");
            const h = t.const("vSchema", o);
            d = X(
              ...a.map((e, t) =>
                (function (e, t) {
                  var r = a[t];
                  return "object" == typeof r && null !== r
                    ? v`${c}(${s}, ${e}[${t}])`
                    : v`${s} === ${r}`;
                })(h, t)
              )
            );
          }
          e.pass(d);
        },
      },
    ],
    (function (e = !1) {
      const t = [Ps, js, Ns, xs, Cs, Is, Es, Ss, gs, ks, _s];
      return e ? t.push(ys, vs) : t.push(us, ms), t.push($s), t;
    })(),
    rt,
    [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples",
    ],
    ["contentMediaType", "contentEncoding", "contentSchema"],
  ];
  function Os(e, t) {
    const { gen: r, it: s } = e;
    s.schemaEnv.root.dynamicAnchors[t] = !0;
    const a = v`${$e.dynamicAnchors}${w(t)}`,
      o =
        "#" === s.errSchemaPath
          ? s.validateName
          : (function (e) {
              var { schemaEnv: t, schema: r, self: s } = e.it,
                { root: a, baseId: o, localRefs: n, meta: i } = t.root,
                { schemaId: t } = s.opts,
                i = new Dr({
                  schema: r,
                  schemaId: t,
                  root: a,
                  baseId: o,
                  localRefs: n,
                  meta: i,
                });
              return qr.call(s, i), as(e, i);
            })(e);
    r.if(v`!${a}`, () => r.assign(a, o));
  }
  function Ds(r, e) {
    const { gen: s, keyword: t, it: a } = r;
    if ("#" !== e[0])
      throw new Error(`"${t}" only supports hash fragment reference`);
    const o = e.slice(1);
    function n(e) {
      var t;
      a.schemaEnv.root.dynamicAnchors[o]
        ? ((t = s.let("_v", v`${$e.dynamicAnchors}${w(o)}`)),
          s.if(t, i(t, e), i(a.validateName, e)))
        : i(a.validateName, e)();
    }
    function i(e, t) {
      return t
        ? () =>
            s.block(() => {
              os(r, e), s.let(t, !0);
            })
        : () => os(r, e);
    }
    a.allErrors ? n() : (n((e = s.let("valid", !1))), r.ok(e));
  }
  const qs = [
      {
        keyword: "$dynamicAnchor",
        schemaType: "string",
        code: (e) => Os(e, e.schema),
      },
      {
        keyword: "$dynamicRef",
        schemaType: "string",
        code: (e) => Ds(e, e.schema),
      },
      {
        keyword: "$recursiveAnchor",
        schemaType: "boolean",
        code(e) {
          e.schema ? Os(e, "") : ve(e.it, "$recursiveAnchor: false is ignored");
        },
      },
      {
        keyword: "$recursiveRef",
        schemaType: "string",
        code: (e) => Ds(e, e.schema),
      },
    ],
    zs = [
      {
        keyword: "dependentRequired",
        type: "object",
        schemaType: "object",
        error: at,
        code: (e) => ws(e),
      },
      {
        keyword: "dependentSchemas",
        type: "object",
        schemaType: "object",
        code: (e) => bs(e),
      },
      {
        keyword: ["maxContains", "minContains"],
        type: "array",
        schemaType: "number",
        code({ keyword: e, parentSchema: t, it: r }) {
          void 0 === t.contains &&
            ve(r, `"${e}" without "contains" is ignored`);
        },
      },
    ],
    Vs = [
      {
        keyword: "unevaluatedProperties",
        type: "object",
        schemaType: ["boolean", "object"],
        trackErrors: !0,
        error: {
          message: "must NOT have unevaluated properties",
          params: ({ params: e }) =>
            v`{unevaluatedProperty: ${e.unevaluatedProperty}}`,
        },
        code(r) {
          const { gen: s, schema: a, data: e, errsCount: t, it: o } = r;
          if (!t) throw new Error("ajv implementation error");
          const { allErrors: n, props: i } = o;
          function c(e) {
            if (!1 === a)
              return (
                r.setParams({ unevaluatedProperty: e }),
                r.error(),
                void (n || s.break())
              );
            var t;
            se(o, a) ||
              ((t = s.name("valid")),
              r.subschema(
                {
                  keyword: "unevaluatedProperties",
                  dataProp: e,
                  dataPropType: b.Str,
                },
                t
              ),
              n || s.if(B(t), () => s.break()));
          }
          i instanceof p
            ? s.if(v`${i} !== true`, () =>
                s.forIn("key", e, (e) =>
                  s.if(
                    (function (e, t) {
                      return v`!${e} || !${e}[${t}]`;
                    })(i, e),
                    () => c(e)
                  )
                )
              )
            : !0 !== i &&
              s.forIn("key", e, (e) =>
                void 0 === i
                  ? c(e)
                  : s.if(
                      (function (e, t) {
                        const r = [];
                        for (const s in e)
                          !0 === e[s] && r.push(v`${t} !== ${s}`);
                        return Z(...r);
                      })(i, e),
                      () => c(e)
                    )
              ),
            (o.props = !0),
            r.ok(v`${t} === ${$e.errors}`);
        },
      },
      {
        keyword: "unevaluatedItems",
        type: "array",
        schemaType: ["boolean", "object"],
        error: {
          message: ({ params: { len: e } }) =>
            f`must NOT have more than ${e} items`,
          params: ({ params: { len: e } }) => v`{limit: ${e}}`,
        },
        code(r) {
          const { gen: s, schema: e, data: t, it: a } = r,
            o = a.items || 0;
          if (!0 !== o) {
            const n = s.const("len", v`${t}.length`);
            if (!1 === e) r.setParams({ len: o }), r.fail(v`${n} > ${o}`);
            else if ("object" == typeof e && !se(a, e)) {
              const i = s.var("valid", v`${n} <= ${o}`);
              s.if(B(i), () =>
                (function (t, e) {
                  s.forRange("i", e, n, (e) => {
                    r.subschema(
                      {
                        keyword: "unevaluatedItems",
                        dataProp: e,
                        dataPropType: b.Num,
                      },
                      t
                    ),
                      a.allErrors || s.if(B(t), () => s.break());
                  });
                })(i, o)
              ),
                r.ok(i);
            }
            a.items = !0;
          }
        },
      },
    ];
  ((qt = Ts = Ts || {}).Tag = "tag"), (qt.Mapping = "mapping");
  const Fs = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: {
      message: ({ params: { discrError: e, tagName: t } }) =>
        e === Ts.Tag
          ? `tag "${t}" must be string`
          : `value of tag "${t}" must be in oneOf`,
      params: ({ params: { discrError: e, tag: t, tagName: r } }) =>
        v`{error: ${e}, tag: ${r}, tagValue: ${t}}`,
    },
    code(r) {
      const { gen: s, data: e, schema: t, parentSchema: c, it: a } = r,
        { oneOf: d } = c;
      if (!a.opts.discriminator)
        throw new Error("discriminator: requires discriminator option");
      const h = t.propertyName;
      if ("string" != typeof h)
        throw new Error("discriminator: requires propertyName");
      if (t.mapping) throw new Error("discriminator: mapping is not supported");
      if (!d) throw new Error("discriminator: requires oneOf keyword");
      const o = s.let("valid", !1),
        n = s.const("tag", v`${e}${w(h)}`);
      s.if(
        v`typeof ${n} == "string"`,
        () =>
          (function () {
            var e = (function () {
              const r = {},
                t = n(c);
              let s = !0;
              for (let e = 0; e < d.length; e++) {
                var a = d[e],
                  o =
                    null === (o = a.properties) || void 0 === o ? void 0 : o[h];
                if ("object" != typeof o)
                  throw new Error(
                    `discriminator: oneOf schemas must have "properties/${h}"`
                  );
                (s = s && (t || n(a))),
                  (function (e, t) {
                    if (e.const) i(e.const, t);
                    else {
                      if (!e.enum)
                        throw new Error(
                          `discriminator: "properties/${h}" must have "const" or "enum"`
                        );
                      for (const r of e.enum) i(r, t);
                    }
                  })(o, e);
              }
              if (!s) throw new Error(`discriminator: "${h}" must be required`);
              return r;
              function n({ required: e }) {
                return Array.isArray(e) && e.includes(h);
              }
              function i(e, t) {
                if ("string" != typeof e || e in r)
                  throw new Error(
                    `discriminator: "${h}" values must be unique strings`
                  );
                r[e] = t;
              }
            })();
            s.if(!1);
            for (const t in e)
              s.elseIf(v`${n} === ${t}`),
                s.assign(
                  o,
                  (function (e) {
                    var t = s.name("valid"),
                      e = r.subschema({ keyword: "oneOf", schemaProp: e }, t);
                    return r.mergeEvaluated(e, p), t;
                  })(e[t])
                );
            s.else(),
              r.error(!1, { discrError: Ts.Mapping, tag: n, tagName: h }),
              s.endIf();
          })(),
        () => r.error(!1, { discrError: Ts.Tag, tag: n, tagName: h })
      ),
        r.ok(o);
    },
  };
  var Ur = "https://json-schema.org/draft/2019-09/schema",
    Mr = "https://json-schema.org/draft/2019-09/schema",
    Kr = {
      "https://json-schema.org/draft/2019-09/vocab/core": !0,
      "https://json-schema.org/draft/2019-09/vocab/applicator": !0,
      "https://json-schema.org/draft/2019-09/vocab/validation": !0,
      "https://json-schema.org/draft/2019-09/vocab/meta-data": !0,
      "https://json-schema.org/draft/2019-09/vocab/format": !1,
      "https://json-schema.org/draft/2019-09/vocab/content": !0,
    },
    is = "Core and Validation specifications meta-schema",
    rt = [
      { $ref: "meta/core" },
      { $ref: "meta/applicator" },
      { $ref: "meta/validation" },
      { $ref: "meta/meta-data" },
      { $ref: "meta/format" },
      { $ref: "meta/content" },
    ],
    at = ["object", "boolean"],
    qt = {
      definitions: {
        $comment:
          "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",
        type: "object",
        additionalProperties: { $recursiveRef: "#" },
        default: {},
      },
      dependencies: {
        $comment:
          '"dependencies" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to "dependentSchemas" and "dependentRequired"',
        type: "object",
        additionalProperties: {
          anyOf: [
            { $recursiveRef: "#" },
            { $ref: "meta/validation#/$defs/stringArray" },
          ],
        },
      },
    },
    Ls = Object.freeze({
      __proto__: null,
      $schema: Ur,
      $id: Mr,
      $vocabulary: Kr,
      $recursiveAnchor: !0,
      title: is,
      allOf: rt,
      type: at,
      properties: qt,
      default: {
        $schema: Ur,
        $id: Mr,
        $vocabulary: Kr,
        $recursiveAnchor: !0,
        title: is,
        allOf: rt,
        type: at,
        properties: qt,
      },
    }),
    Ur = "https://json-schema.org/draft/2019-09/schema",
    Mr = "https://json-schema.org/draft/2019-09/meta/applicator",
    Kr = { "https://json-schema.org/draft/2019-09/vocab/applicator": !0 },
    is = "Applicator vocabulary meta-schema",
    rt = ["object", "boolean"],
    at = {
      additionalItems: { $recursiveRef: "#" },
      unevaluatedItems: { $recursiveRef: "#" },
      items: {
        anyOf: [{ $recursiveRef: "#" }, { $ref: "#/$defs/schemaArray" }],
      },
      contains: { $recursiveRef: "#" },
      additionalProperties: { $recursiveRef: "#" },
      unevaluatedProperties: { $recursiveRef: "#" },
      properties: {
        type: "object",
        additionalProperties: { $recursiveRef: "#" },
        default: {},
      },
      patternProperties: {
        type: "object",
        additionalProperties: { $recursiveRef: "#" },
        propertyNames: { format: "regex" },
        default: {},
      },
      dependentSchemas: {
        type: "object",
        additionalProperties: { $recursiveRef: "#" },
      },
      propertyNames: { $recursiveRef: "#" },
      if: { $recursiveRef: "#" },
      then: { $recursiveRef: "#" },
      else: { $recursiveRef: "#" },
      allOf: { $ref: "#/$defs/schemaArray" },
      anyOf: { $ref: "#/$defs/schemaArray" },
      oneOf: { $ref: "#/$defs/schemaArray" },
      not: { $recursiveRef: "#" },
    },
    qt = {
      schemaArray: {
        type: "array",
        minItems: 1,
        items: { $recursiveRef: "#" },
      },
    },
    Us = Object.freeze({
      __proto__: null,
      $schema: Ur,
      $id: Mr,
      $vocabulary: Kr,
      $recursiveAnchor: !0,
      title: is,
      type: rt,
      properties: at,
      $defs: qt,
      default: {
        $schema: Ur,
        $id: Mr,
        $vocabulary: Kr,
        $recursiveAnchor: !0,
        title: is,
        type: rt,
        properties: at,
        $defs: qt,
      },
    }),
    Ur = "https://json-schema.org/draft/2019-09/schema",
    Mr = "https://json-schema.org/draft/2019-09/meta/content",
    Kr = { "https://json-schema.org/draft/2019-09/vocab/content": !0 },
    is = "Content vocabulary meta-schema",
    rt = ["object", "boolean"],
    at = {
      contentMediaType: { type: "string" },
      contentEncoding: { type: "string" },
      contentSchema: { $recursiveRef: "#" },
    },
    Ms = Object.freeze({
      __proto__: null,
      $schema: Ur,
      $id: Mr,
      $vocabulary: Kr,
      $recursiveAnchor: !0,
      title: is,
      type: rt,
      properties: at,
      default: {
        $schema: Ur,
        $id: Mr,
        $vocabulary: Kr,
        $recursiveAnchor: !0,
        title: is,
        type: rt,
        properties: at,
      },
    }),
    qt = "https://json-schema.org/draft/2019-09/schema",
    Ur = "https://json-schema.org/draft/2019-09/meta/core",
    Mr = { "https://json-schema.org/draft/2019-09/vocab/core": !0 },
    Kr = "Core vocabulary meta-schema",
    is = ["object", "boolean"],
    rt = {
      $id: {
        type: "string",
        format: "uri-reference",
        $comment: "Non-empty fragments not allowed.",
        pattern: "^[^#]*#?$",
      },
      $schema: { type: "string", format: "uri" },
      $anchor: { type: "string", pattern: "^[A-Za-z][-A-Za-z0-9.:_]*$" },
      $ref: { type: "string", format: "uri-reference" },
      $recursiveRef: { type: "string", format: "uri-reference" },
      $recursiveAnchor: { type: "boolean", default: !1 },
      $vocabulary: {
        type: "object",
        propertyNames: { type: "string", format: "uri" },
        additionalProperties: { type: "boolean" },
      },
      $comment: { type: "string" },
      $defs: {
        type: "object",
        additionalProperties: { $recursiveRef: "#" },
        default: {},
      },
    },
    Ks = Object.freeze({
      __proto__: null,
      $schema: qt,
      $id: Ur,
      $vocabulary: Mr,
      $recursiveAnchor: !0,
      title: Kr,
      type: is,
      properties: rt,
      default: {
        $schema: qt,
        $id: Ur,
        $vocabulary: Mr,
        $recursiveAnchor: !0,
        title: Kr,
        type: is,
        properties: rt,
      },
    }),
    at = "https://json-schema.org/draft/2019-09/schema",
    qt = "https://json-schema.org/draft/2019-09/meta/format",
    Ur = { "https://json-schema.org/draft/2019-09/vocab/format": !0 },
    Mr = "Format vocabulary meta-schema",
    Kr = ["object", "boolean"],
    is = { format: { type: "string" } },
    Gs = Object.freeze({
      __proto__: null,
      $schema: at,
      $id: qt,
      $vocabulary: Ur,
      $recursiveAnchor: !0,
      title: Mr,
      type: Kr,
      properties: is,
      default: {
        $schema: at,
        $id: qt,
        $vocabulary: Ur,
        $recursiveAnchor: !0,
        title: Mr,
        type: Kr,
        properties: is,
      },
    }),
    rt = "https://json-schema.org/draft/2019-09/schema",
    at = "https://json-schema.org/draft/2019-09/meta/meta-data",
    qt = { "https://json-schema.org/draft/2019-09/vocab/meta-data": !0 },
    Ur = "Meta-data vocabulary meta-schema",
    Mr = ["object", "boolean"],
    Kr = {
      title: { type: "string" },
      description: { type: "string" },
      default: !0,
      deprecated: { type: "boolean", default: !1 },
      readOnly: { type: "boolean", default: !1 },
      writeOnly: { type: "boolean", default: !1 },
      examples: { type: "array", items: !0 },
    },
    Hs = Object.freeze({
      __proto__: null,
      $schema: rt,
      $id: at,
      $vocabulary: qt,
      $recursiveAnchor: !0,
      title: Ur,
      type: Mr,
      properties: Kr,
      default: {
        $schema: rt,
        $id: at,
        $vocabulary: qt,
        $recursiveAnchor: !0,
        title: Ur,
        type: Mr,
        properties: Kr,
      },
    }),
    is = "https://json-schema.org/draft/2019-09/schema",
    rt = "https://json-schema.org/draft/2019-09/meta/validation",
    at = { "https://json-schema.org/draft/2019-09/vocab/validation": !0 },
    qt = "Validation vocabulary meta-schema",
    Ur = ["object", "boolean"],
    Mr = {
      multipleOf: { type: "number", exclusiveMinimum: 0 },
      maximum: { type: "number" },
      exclusiveMaximum: { type: "number" },
      minimum: { type: "number" },
      exclusiveMinimum: { type: "number" },
      maxLength: { $ref: "#/$defs/nonNegativeInteger" },
      minLength: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
      pattern: { type: "string", format: "regex" },
      maxItems: { $ref: "#/$defs/nonNegativeInteger" },
      minItems: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
      uniqueItems: { type: "boolean", default: !1 },
      maxContains: { $ref: "#/$defs/nonNegativeInteger" },
      minContains: { $ref: "#/$defs/nonNegativeInteger", default: 1 },
      maxProperties: { $ref: "#/$defs/nonNegativeInteger" },
      minProperties: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
      required: { $ref: "#/$defs/stringArray" },
      dependentRequired: {
        type: "object",
        additionalProperties: { $ref: "#/$defs/stringArray" },
      },
      const: !0,
      enum: { type: "array", items: !0 },
      type: {
        anyOf: [
          { $ref: "#/$defs/simpleTypes" },
          {
            type: "array",
            items: { $ref: "#/$defs/simpleTypes" },
            minItems: 1,
            uniqueItems: !0,
          },
        ],
      },
    },
    Kr = {
      nonNegativeInteger: { type: "integer", minimum: 0 },
      nonNegativeIntegerDefault0: {
        $ref: "#/$defs/nonNegativeInteger",
        default: 0,
      },
      simpleTypes: {
        enum: [
          "array",
          "boolean",
          "integer",
          "null",
          "number",
          "object",
          "string",
        ],
      },
      stringArray: {
        type: "array",
        items: { type: "string" },
        uniqueItems: !0,
        default: [],
      },
    },
    Ws = Object.freeze({
      __proto__: null,
      $schema: is,
      $id: rt,
      $vocabulary: at,
      $recursiveAnchor: !0,
      title: qt,
      type: Ur,
      properties: Mr,
      $defs: Kr,
      default: {
        $schema: is,
        $id: rt,
        $vocabulary: at,
        $recursiveAnchor: !0,
        title: qt,
        type: Ur,
        properties: Mr,
        $defs: Kr,
      },
    });
  const Js = ["/properties"];
  const Bs = "https://json-schema.org/draft/2019-09/schema";
  class Qs extends Qr {
    constructor(e = {}) {
      super({ ...e, dynamicRef: !0, next: !0, unevaluated: !0 });
    }
    _addVocabularies() {
      super._addVocabularies(),
        this.addVocabulary(qs),
        Rs.forEach((e) => this.addVocabulary(e)),
        this.addVocabulary(zs),
        this.addVocabulary(Vs),
        this.opts.discriminator && this.addKeyword(Fs);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      var { $data: e, meta: t } = this.opts;
      t &&
        (!function (r) {
          return (
            [Ls, Us, Ms, Ks, e(this, Gs), Hs, e(this, Ws)].forEach((e) =>
              this.addMetaSchema(e, void 0, !1)
            ),
            this
          );
          function e(e, t) {
            return r ? e.$dataMetaSchema(t, Js) : t;
          }
        }.call(this, e),
        (this.refs["http://json-schema.org/schema"] = Bs));
    }
    defaultMeta() {
      return (this.opts.defaultMeta =
        super.defaultMeta() || (this.getSchema(Bs) ? Bs : void 0));
    }
  }
  (module.exports = e = Qs),
    Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.CodeGen = G),
    (e.KeywordCxt = Cr),
    (e.Name = p),
    (e._ = v),
    (e.default = Qs),
    (e.nil = y),
    (e.str = f),
    (e.stringify = g),
    Object.defineProperty(e, "__esModule", { value: !0 });
});
